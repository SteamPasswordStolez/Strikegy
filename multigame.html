<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Strikegy ‚Äî MultiGame (Patch 11-D1)</title>
  <style>
    :root{
      --bg:#0b0f17; --text:#eaf0ff; --muted:#9fb0d0; --line:rgba(255,255,255,.12);
      --panel:rgba(17,26,43,.82);
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family:system-ui, -apple-system, "Noto Sans KR", Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }
    #hud{
      position:fixed; left:14px; top:14px;
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px 12px;
      min-width: 280px;
      box-shadow:0 16px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      z-index:10;
    }
    #hud h1{font-size:14px; margin:0 0 8px; letter-spacing:.3px}
    .row{display:flex; justify-content:space-between; gap:10px; align-items:center; margin:6px 0}
    .k{color:var(--muted); font-size:12px}
    .v{font-weight:800; font-size:12.5px}
    .btns{display:flex; gap:8px; margin-top:10px}
    button{
      border:1px solid var(--line);
      background:rgba(26,42,68,.9);
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:800;
      font-size:12.5px;
    }
    button:hover{filter:brightness(1.05)}
    #status{margin-top:8px; color:var(--muted); font-size:12px; line-height:1.35}
    #overlayError{
      position:fixed; inset:0; display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.55);
      z-index:30;
      padding:24px;
    }
    #overlayError .card{
      width:min(860px, 100%);
      background:rgba(17,26,43,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:16px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
    }
    #overlayError h2{margin:0 0 8px; font-size:16px}
    #overlayError pre{
      margin:10px 0 0;
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:12px;
      overflow:auto;
      max-height:45vh;
      color:#ffd9d9;
      font-size:12px;
      line-height:1.35;
      white-space:pre-wrap;
      word-break:break-word;
    }

    /* ---- Patch 10: In-game menu (official UI) ---- */
    #gameMenuBtn{
      position:fixed;
      left:14px;
      top:14px;
      z-index:60;
      width:44px;
      height:44px;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(17,26,43,.70);
      backdrop-filter: blur(6px);
      color:var(--text);
      font-weight:900;
      font-size:18px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #gameMenuBtn:hover{filter:brightness(1.06)}
    #gameMenuOverlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.55);
      z-index:70;
      padding:24px;
    }
    #gameMenuOverlay.open{display:flex}
    #gameMenuCard{
      width:min(520px, 100%);
      background:rgba(17,26,43,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:16px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
    }
    #gameMenuCard h2{margin:0 0 10px; font-size:16px}
    #gameMenuCard .menuBtns{display:grid; gap:10px}
    #gameMenuCard .menuBtns button{width:100%; justify-content:center}
    canvas{display:block}

    /* ---- Patch 7-2B: Scope overlay ---- */
    #scopeOverlay{
      position:fixed;
      inset:0;
      display:none;
      pointer-events:none;
      z-index:45;
    }
    #scopeOverlay .mask{
      position:absolute;
      inset:0;
      /* Center circle: transparent, outside: dark */
      background:
        radial-gradient(circle at center,
          rgba(0,0,0,0) 0%,
          rgba(0,0,0,0) 38%,
          rgba(0,0,0,0.75) 40%,
          rgba(0,0,0,0.95) 100%);
    }
    #scopeOverlay .reticle{
      position:absolute;
      left:50%; top:50%;
      width:520px; height:520px;
      transform:translate(-50%,-50%);
      border:2px solid rgba(255,255,255,0.85);
      border-radius:999px;
      box-sizing:border-box;
    }
    #scopeOverlay .reticle:before,
    #scopeOverlay .reticle:after{
      content:"";
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      background:rgba(255,255,255,0.85);
    }
    #scopeOverlay .reticle:before{ width:2px; height:520px; }
    #scopeOverlay .reticle:after{ width:520px; height:2px; }

    /* Mild scope-specific tweaks */
    #scopeOverlay[data-scope="3x"] .reticle{ width:480px; height:480px; }
    #scopeOverlay[data-scope="6x"] .reticle{ width:520px; height:520px; }
    #scopeOverlay[data-scope="8x"] .reticle{ width:560px; height:560px; border-width:2px; }

    /* ---- Patch 7-4B: Binocular overlay (separate from scope) ---- */
    #binoOverlay{position:fixed;inset:0;display:none;pointer-events:none;z-index:45;}
    #binoOverlay .mask{position:absolute;inset:0;background:
      radial-gradient(circle at center,
        rgba(0,0,0,0) 0%,
        rgba(0,0,0,0) 46%,
        rgba(0,0,0,0.55) 49%,
        rgba(0,0,0,0.92) 100%);
    }
    #binoOverlay .reticle{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:560px;height:560px;border:2px solid rgba(255,255,255,0.65);border-radius:999px;box-sizing:border-box;
    }
    #binoOverlay .reticle:after{content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:8px;height:8px;border-radius:999px;background:rgba(255,255,255,0.85);
    }

    /* ---- Patch 7-4A: Smoke / Flash overlays ---- */
    #smokeOverlay, #flashOverlay{
      position: fixed;
      inset: 0;
      display: block;
      pointer-events: none;
      opacity: 0;
      z-index: 46;
    }
    #smokeOverlay{
      background: rgba(160, 175, 200, 0.20);
      backdrop-filter: blur(0px);
      -webkit-backdrop-filter: blur(0px);
      transition: opacity 80ms linear;
    }
    #flashOverlay{
      background: rgba(255,255,255,1);
      transition: opacity 45ms linear;
    }
  
    /* ---- Mobile HUD ---- */
.mobileHUD{
  position: fixed; inset: 0;
  pointer-events: none;
  z-index: 40;
  /* iOS safe area */
  --safeB: env(safe-area-inset-bottom, 0px);
  --safeR: env(safe-area-inset-right, 0px);
  --safeL: env(safe-area-inset-left, 0px);
  --safeT: env(safe-area-inset-top, 0px);

  --uiScale: 1;
  --btnSize: calc(60px * var(--uiScale));
  --btnSizeSm: calc(56px * var(--uiScale));
  --btnSizeJump: calc(64px * var(--uiScale));
  --btnSizeFire: calc(88px * var(--uiScale));
  --ammoPad: calc(110px * var(--uiScale));

  --gap: calc(10px * var(--uiScale));
}
.mobileHUD.hidden{ display:none; }

/* Left move zone */
.mh-joystickArea{
  position:absolute;
  left:0; bottom:0;
  width: 45vw;
  height: 55vh;
  pointer-events: auto;
  touch-action: none;
}
.mh-joyBase{
  position: fixed;
  width: 140px; height: 140px;
  border-radius: 999px;
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.18);
  transform: translate(-50%, -50%);
  display:none;
  pointer-events:none;
  z-index: 41;
}
.mh-joyBase.show{ display:block; }
.mh-joyKnob{
  position:absolute;
  left:50%; top:50%;
  width: 52px; height: 52px;
  border-radius: 999px;
  background: rgba(255,255,255,0.14);
  border: 1px solid rgba(255,255,255,0.22);
  transform: translate(-50%, -50%);
}

/* Combat cluster (right-bottom) */
.mh-combat{
  position:absolute;
  right: calc(18px + var(--safeR) + var(--ammoPad));
  bottom: calc(18px + var(--safeB));
  display:flex;
  flex-direction: column;
  align-items: flex-end;
  gap: var(--gap);
  pointer-events:auto;
  touch-action: none;
  z-index: 41;
}

/* Actions stack (jump/crouch/sprint) slightly above combat */
.mh-actions{
  position:absolute;
  right: calc(18px + var(--safeR));
  bottom: calc(18px + var(--safeB) + var(--ammoPad));
  display:flex;
  flex-direction: column;
  align-items: flex-end;
  gap: var(--gap);
  pointer-events:auto;
  touch-action: none;
  z-index: 41;
}

.mh-btn{
  width: var(--btnSize);
  height: var(--btnSize);
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.22);
  background: rgba(20,20,20,.55);
  color: #fff;
  font-weight: 800;
  font-size: 22px;
  line-height: 1;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:auto;
  user-select:none;
  -webkit-user-select:none;
  -webkit-tap-highlight-color: transparent;
}

/* Patch 9-4F: utility */
.mh-hidden{ display:none !important; }
.mh-btn--small{
  width: var(--btnSizeSm);
  height: var(--btnSizeSm);
  font-size: 20px;
}
.mh-btn--fire{
  width: var(--btnSizeFire);
  height: var(--btnSizeFire);
  font-size: 26px;
  border-color: rgba(255,120,120,0.45);
  background: rgba(50,15,15,.55);
}


.mh-btn--jump{
  width: var(--btnSizeJump);
  height: var(--btnSizeJump);
  font-size: 24px;
}
.mh-btn.on{
  outline: 2px solid rgba(255,255,255,.35);
}
.mh-btn.active{
  outline: 3px solid rgba(120,200,255,.75);
  box-shadow: 0 0 18px rgba(120,200,255,.35);
}
.mh-btn.pulse{
  transform: scale(0.94);
}

.mh-lookHint{
  position:absolute;
  right: calc(18px + var(--safeR) + var(--ammoPad));
  top: calc(10px + var(--safeT));
  color: rgba(255,255,255,.55);
  font-size: 12px;
  pointer-events:none;
  z-index: 41;
}
/* ---- End Mobile HUD ---- */
/* ---- Crosshair ---- */
    .crosshair{
      position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%);
      width: 18px; height: 18px; z-index: 44; pointer-events:none;
    }
    .crosshair::before, .crosshair::after{
      content:""; position:absolute; left:50%; top:50%;
      background: rgba(255,255,255,.92);
      box-shadow: 0 2px 10px rgba(0,0,0,.55);
    }
    .crosshair::before{ width: 2px; height: 18px; transform: translate(-50%,-50%); }
    .crosshair::after{ width: 18px; height: 2px; transform: translate(-50%,-50%); }

    /* Patch 9-4D: Battlefield-like floating reward texts */
    .rewardFloat{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index: 50;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, sans-serif;
      font-weight: 800;
      letter-spacing: 0.2px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.55);
    }
    .rewardFloat__line{
      position:absolute;
      left:0;
      top:0;
      white-space:nowrap;
      opacity:0;
      transform: translate(-50%, 10px) scale(0.98);
      transition: opacity 120ms linear;
      font-size: 15px;
    }
    .rewardFloat__line.show{ opacity:1; }

    /* ---- Ammo HUD (bottom-right, vertical; BF-style) ---- */
    .ammoHUD{
      position: fixed;
      right: 18px;
      bottom: 18px;
      z-index: 44;
      color: rgba(255,255,255,.96);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      text-align: right;
      pointer-events:none;
      user-select:none;
      filter: drop-shadow(0 6px 14px rgba(0,0,0,.45));
    }
    .ammoWeapon{

      font-weight: 800;
      font-size: 12px;
      letter-spacing: .06em;
      opacity: .85;
      margin-bottom: 6px;
    }
    .ammoNums{
      display:flex;
      flex-direction: column;
      align-items: flex-end;
      line-height: 1;
    }
    #ammoMag{ font-size: 40px; font-weight: 900; }
    .ammoSep{ font-size: 10px; opacity:.55; margin: 6px 0; }
    #ammoRes{ font-size: 16px; font-weight: 800; opacity:.85; }
    .ammoStatus{
      margin-top: 6px;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: .08em;
      opacity: .9;
      min-height: 14px;
    }
    .ammoStatus.blink{
      animation: blink 0.6s steps(2,end) infinite;
    }
    @keyframes blink{ 50%{ opacity: .15; } }

    /* ---- Patch 7-4B: Binocular HUD (only while binocular aiming) ---- */
    .binoHUD{
      position: fixed;
      right: 18px;
      bottom: 108px;
      z-index: 45;
      display: flex;
      align-items: center;
      gap: 10px;
      pointer-events: auto;
      user-select:none;
      filter: drop-shadow(0 6px 14px rgba(0,0,0,.45));
    }
    .binoText{
      color: rgba(255,255,255,.95);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 900;
      letter-spacing: .06em;
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      min-width: 54px;
      text-align: center;
    }
    .binoBtn{
      width: 40px;
      height: 40px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.95);
      font-size: 18px;
      font-weight: 900;
      cursor: pointer;
    }
    .binoBtn:active{ transform: scale(0.96); }
    
  
    /* ---- Patch 6-1b: Inventory (Modal) ---- */
    #invBagBtn{
      position:fixed;
      top:10px; right:10px;
      width:46px; height:46px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(17,26,43,.78);
      color:#eaf0ff;
      font-size:22px;
      line-height:1;
      display:none;
      z-index: 55;
      pointer-events:auto;
      backdrop-filter: blur(6px);
      box-shadow:0 10px 24px rgba(0,0,0,.35);
      cursor:pointer;
    }
    #invBagBtn:active{ transform: translateY(1px); }
    @supports (padding: env(safe-area-inset-top)){
      #invBagBtn{
        top: calc(10px + env(safe-area-inset-top));
        right: calc(10px + env(safe-area-inset-right));
      }
    }

    
    /* ---- Patch 6-2b: Shop + Money HUD ---- */
    #moneyHUD{
      position:fixed;
      top:64px; left:14px;
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(17,26,43,.78);
      color:#eaf0ff;
      font-size:14px;
      letter-spacing:.2px;
      z-index: 60;
      pointer-events:none;
      backdrop-filter: blur(6px);
      box-shadow:0 10px 24px rgba(0,0,0,.35);
      display:none;
    }
    #shopCartBtn{
      position:fixed;
      top:10px; right:62px;
      width:46px; height:46px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(17,26,43,.78);
      color:#eaf0ff;
      font-size:22px;
      line-height:1;
      display:none;
      z-index: 60;
      pointer-events:auto;
      backdrop-filter: blur(6px);
      box-shadow:0 10px 24px rgba(0,0,0,.35);
      cursor:pointer;
    }
    #shopCartBtn:active{ transform: translateY(1px); }
    @supports (padding: env(safe-area-inset-top)){
      #moneyHUD{
        top: calc(64px + env(safe-area-inset-top));
        left: calc(14px + env(safe-area-inset-left));
      }
      #shopCartBtn{
        top: calc(10px + env(safe-area-inset-top));
        right: calc(62px + env(safe-area-inset-right));
      }
    }

    .shopOverlay{
      position:fixed; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.55);
      z-index: 90;
      pointer-events:auto;
    }
    .shopModal{
      width:min(620px, calc(100vw - 24px));
      max-height: min(84vh, 760px);
      overflow:auto;
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: 18px;
      box-shadow:0 22px 70px rgba(0,0,0,.55);
      padding: 14px;
    }
    .shopHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .shopTitle{ font-weight:900; font-size:18px; }
    .shopMoney{ font-weight:800; opacity:.95; }
    .shopClose{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:#eaf0ff;
      border-radius: 10px;
      padding:6px 10px;
      cursor:pointer;
    }
    .shopTabs{ display:flex; gap:8px; margin:10px 0 12px; flex-wrap:wrap; }
    .shopTab{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color:#eaf0ff;
      border-radius: 999px;
      padding:8px 10px;
      cursor:pointer;
      font-size:13px;
    }
    .shopTab.active{ background: rgba(105,169,255,.18); border-color: rgba(105,169,255,.35); }
    .shopList{ display:flex; flex-direction:column; gap:8px; }
    .shopSection{ margin-top:4px; font-weight:800; opacity:.9; }
    .shopItem{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:10px;
      background: rgba(255,255,255,.03);
    }
    .shopItemLeft{ display:flex; align-items:center; gap:10px; }
    .shopIcon{ width:36px; height:36px; border-radius:12px; display:flex; align-items:center; justify-content:center;
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10); }
    .shopMid{ display:flex; flex-direction:column; gap:2px; }
    .shopName{ font-weight:800; }
    .shopSub{ font-size:12px; opacity:.85; }
    .shopBuy{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(105,169,255,.16);
      color:#eaf0ff;
      border-radius: 12px;
      padding:8px 12px;
      cursor:pointer;
      font-weight:800;
      white-space:nowrap;
    }
    .shopBuy.disabled{ opacity:.45; cursor:not-allowed; }
    .shopBuy:disabled{ opacity:.45; cursor:not-allowed; }
    .shopHint{ font-size:12px; opacity:.75; margin-top:6px; }
    .shopToast{ margin-top:10px; font-size:13px; opacity:0; transition: opacity .12s ease; }
    

.invOverlay{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.55);
      z-index: 80;
      pointer-events:auto;
    }
    .invModal{
      width:min(540px, calc(100vw - 24px));
      max-height: min(82vh, 720px);
      overflow:auto;
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: 18px;
      box-shadow:0 22px 70px rgba(0,0,0,.55);
      padding: 14px;
    }
    .invHeader{
      display:flex;
      align-items:center;
      gap:10px;
      padding-bottom: 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      margin-bottom: 12px;
    }
    .invTitle{ font-weight:900; letter-spacing:.02em; }
    .invSub{ opacity:.85; margin-left:auto; }
    .invCloseBtn{
      margin-left:8px;
      width:36px; height:36px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.12);
      color:#eaf0ff;
      cursor:pointer;
    }
    .invGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:10px;
    }
    @media (max-width: 520px){
      .invGrid{ grid-template-columns: 1fr; }
    }
    .invSlot{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      gap:4px;
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.10);
      color:#eaf0ff;
      cursor:pointer;
      text-align:left;
      user-select:none;
    }
    .invSlot.is-selected{
      border-color: rgba(31,79,255,.95);
      box-shadow: 0 0 0 2px rgba(31,79,255,.35) inset;
    }
    .invSlot.is-locked{
      opacity:.8;
      background:rgba(0,0,0,.06);
    }
    .invSlotIcon{ font-size:22px; }
    .invSlotLabel{ font-size:12px; opacity:.75; }
    .invSlotName{ font-size:13px; font-weight:800; opacity:.92; }

    .ammoSlot{ margin-top: 2px; font-size: 11px; font-weight: 800; letter-spacing: .08em; opacity: .72; }


  /* Patch 8-1: Minimap (top-right) */
  #minimapWrap{
    position:fixed;
    top:16px;
    right:16px;
    width:220px;
    height:220px;
    z-index:40;
    border-radius:50%;
    overflow:hidden;
    pointer-events:none;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  #minimapCanvas{
    width:100%;
    height:100%;
    display:block;
  }
  @media (max-width: 820px){
    #minimapWrap{ width:160px; height:160px; top:12px; right:12px; }
  }
</style>
</head>
<body>
  <!-- Patch 10: remove dev HUD (official build) -->
  <div id="camHud" style="display:none"></div>

  

  <div id="minimapWrap" aria-label="Minimap">
    <canvas id="minimapCanvas" width="220" height="220"></canvas>
  </div>

  <button id="gameMenuBtn" aria-label="Menu" title="Menu">‚öô</button>
  <div id="gameMenuOverlay" aria-hidden="true">
    <div id="gameMenuCard" role="dialog" aria-modal="true" aria-labelledby="gameMenuTitle">
      <h2 id="gameMenuTitle">Menu</h2>
      <div class="menuBtns">
        <button id="gmResume">Resume</button>
        <button id="gmReload">Reload</button>
        <button id="gmLobby">Back to Lobby</button>
      </div>
      <div style="margin-top:10px;color:var(--muted);font-size:12px;line-height:1.5">
        ESCÎ°ú Îã´Í∏∞ ¬∑ Î™®Î∞îÏùºÏùÄ ÏÑ§Ï†ï Î©îÎâ¥ Î≤ÑÌäºÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.
      </div>
    </div>
  </div>

<div id="hud" role="group" aria-label="Map Loader" style="display:none">
    <h1>Map Loader</h1>
    <div class="row"><span class="k">Selected Mode</span><span class="v" id="modeLabel">-</span></div>
    <div class="row"><span class="k">Map</span><span class="v" id="mapLabel">-</span></div>
    <div class="row"><span class="k">World</span><span class="v" id="worldLabel">-</span></div>
    <div class="row"><span class="k">Zones</span><span class="v" id="zonesLabel">-</span></div>
    <div class="btns">
      <button id="backBtn" title="Î°úÎπÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞">Lobby</button>
      <button id="reloadBtn" title="Îßµ Ïû¨Î°úÎìú">Reload</button>
    </div>
    <div id="status">3D Ïî¨ Î°úÎî© Ï§ë‚Ä¶</div>
  </div>

  <div id="overlayError" aria-live="polite">
    <div class="card">
      <h2>Îßµ Î°úÎìú Ïã§Ìå®</h2>
      <div class="row"><span class="k">Tried</span><span class="v" id="failPath">-</span></div>
      <div class="btns">
        <button id="retryBtn">Retry</button>
        <button id="toLobbyBtn">Back to Lobby</button>
      </div>
      <pre id="failLog"></pre>
    </div>
  </div>

  <script type="module">
  import MuzzleFlash from "./src/effects/MuzzleFlash.js";
  import CasingSystem from "./src/effects/CasingSystem.js";
  import SoundSystem from "./src/audio/SoundSystem.js";
    import { SettingsStore } from "./src/core/SettingsStore.js";
    import { InputManager } from "./src/input/InputManager.js";
    import { CameraController } from "./src/camera/CameraController.js";
    import PlayerController from './src/player/PlayerController.js';
    import CollisionWorld from './src/world/CollisionWorld.js';
    import MobileHUD from './src/ui/MobileHUD.js';
    import { MinimapUI } from "./src/ui/MinimapUI.js";
    import { BotManager } from "./src/bots/BotManager.js";
    import { CombatOverlayUI } from './src/ui/CombatOverlayUI.js';
  import { DamageSystem } from './src/combat/DamageSystem.js';
  import { ModeSystem } from "./src/game/ModeSystem.js";
    import InventoryModal from './src/ui/InventoryModal.js';
    import ShopModal from './src/ui/ShopModal.js';
    import { ShopSystem } from './src/game/ShopSystem.js';
  import { AmmoRefillService } from './src/game/AmmoRefillService.js';
  import { ClassItemSystem } from './src/game/ClassItemSystem.js';
  // Patch 11-D1: in-game WS client (authoritative movement + snapshots)
  import { LobbyWSClient } from './src/net/LobbyWSClient.js';
  import { C2S, S2C } from './src/net/protocol.js';
    
  import { EconomyManager } from "./src/game/EconomyManager.js";
  import { LoadoutManager } from "./src/game/LoadoutManager.js";
  import { WeaponSwitchManager } from "./src/game/WeaponSwitchManager.js";
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import WeaponSystem from "./src/weapons/WeaponSystem.js";
  import ThrowablesSystem from "./src/weapons/ThrowablesSystem.js";
  import DecalManager from "./src/effects/DecalManager.js";
  import { CLASS_KEY, normalizeClassId, initInventoryForClass, CLASSES } from "./src/data/classes.js";
    // Patch 6-2a: economy manager instance (declared early to avoid TDZ)
    let economyManager = null;
    let ammoRefillService = null;
    let classItemSystem = null;

    // ---------------------------
    // Patch 3: Mode -> Map ÏÑ†ÌÉù(Registry)
    // ---------------------------
    const MODE_KEY = "selectedMode";
    const SETTINGS_KEY = "strikegy_settings";

    const DEFAULT_MAP_BY_MODE = {
      zone: "maps/zone_5_v1.json",
      conquest: "maps/conquest_5_v1.json",
      frontline: "maps/frontline_6_lane_v1.json",
    };

    function safeGetLocal(key, fallback=null){
      try { return localStorage.getItem(key) ?? fallback; } catch { return fallback; }
    }

    function getSelectedMode(){
      const m = safeGetLocal(MODE_KEY, "zone");
      return (m === "zone" || m === "conquest" || m === "frontline") ? m : "zone";
    }


    // ---------------------------
    // Patch 6-1a: Class selection (from lobby)
    // ---------------------------
    function getSelectedClass(){
      const c = safeGetLocal(CLASS_KEY, "assault");
      return normalizeClassId(c);
    }

    function resolveMapPath(){
      // (ÌôïÏû•Ïö©) ÏøºÎ¶¨Î°ú map=... ÏßÄÏ†ï Í∞ÄÎä•. ÏóÜÏúºÎ©¥ Î™®Îìú Í∏∞Î≥∏Îßµ.
      const url = new URL(window.location.href);
      const map = url.searchParams.get("map");
      const mode = getSelectedMode();
      if (map && map.startsWith("maps/") && map.endsWith(".json")) return map;
      return DEFAULT_MAP_BY_MODE[mode] || DEFAULT_MAP_BY_MODE.zone;
    }

    // ---------------------------
    // Patch 11-D1: Multiplayer runtime (WS authoritative movement + remote capsules)
    // - Uses the same WS connection as lobby/room
    // - Only synces: position + yaw (for now)
    // ---------------------------
    (function initMultiplayerRuntime(){
      const params = new URLSearchParams(location.search);
      const enabled = params.get('mp') === '1';
      const roomId = params.get('room') || sessionStorage.getItem('mp_roomId') || '';

      // Expose a small debug surface
      const mp = {
        enabled,
        roomId,
        client: null,
        youId: null,
        lastSnapshot: null,
        remote: new Map(), // playerId -> { mesh }
        _sendAcc: 0,
      };
      window.__mp = mp;

      if (!enabled) return;
      if (!roomId) {
        console.warn('[MP] missing room id');
        return;
      }

      // server url (same default used by multiplay.html)
      const wsUrl = sessionStorage.getItem('mp_serverUrl') || 'wss://ws.strikegy.org/ws';
      const c = new LobbyWSClient(wsUrl);
      mp.client = c;

      c.on('open', () => {
        // Patch 11-D1: reclaim old playerId across page navigation if possible
        const token = sessionStorage.getItem('mp_reconnectToken') || '';
        if (token) c.reconnect(token);
        else c.joinRoom(roomId);
      });

      c.on(S2C.INIT, (m) => {
        mp.youId = m?.you?.id || null;
      });

      c.on(S2C.GAME_SNAPSHOT, (m) => {
        if (!m || m.roomId !== mp.roomId) return;
        mp.lastSnapshot = m;
      });

      c.on(S2C.ERROR, (m) => {
        console.error('[MP] server error', m);
      });

      c.connect({ reconnect: true });

      function ensureRemoteMesh(scene, pid){
        if (mp.remote.has(pid)) return mp.remote.get(pid);
        const mesh = makeCapsuleMesh();
        mesh.name = `mp_remote_${pid}`;
        scene.add(mesh);
        const entry = { mesh };
        mp.remote.set(pid, entry);
        return entry;
      }

      function makeCapsuleMesh(){
        // simple capsule (cylinder + 2 spheres)
        const g = new THREE.Group();
        const r = 0.38;
        const h = 1.6;
        const cylH = Math.max(0.2, h - r*2);
        const mat = new THREE.MeshStandardMaterial({ color: 0xff7a8a, roughness: 0.9, metalness: 0.0 });
        const cyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, cylH, 10), mat);
        cyl.position.y = r + cylH/2;
        const top = new THREE.Mesh(new THREE.SphereGeometry(r, 10, 10), mat);
        top.position.y = r + cylH;
        const bot = new THREE.Mesh(new THREE.SphereGeometry(r, 10, 10), mat);
        bot.position.y = r;
        g.add(cyl, top, bot);
        return g;
      }

      // Called from the main animate loop (patched near playerController.update)
      mp._sendInputTick = function(dt, { moveX, moveZ, sprint, camera }){
        if (!mp.client || !mp.client.isOpen) return;
        mp._sendAcc += dt;
        const SEND_HZ = 20;
        const step = 1 / SEND_HZ;
        if (mp._sendAcc < step) return;
        mp._sendAcc = mp._sendAcc % step;

        // yaw in radians (match minimap fallback: atan2(dir.x, dir.z))
        let yaw = 0;
        try {
          const dir = new THREE.Vector3();
          camera.getWorldDirection(dir);
          yaw = Math.atan2(dir.x, dir.z);
        } catch (e) {
          yaw = Number(camera?.rotation?.y) || 0;
        }

        mp.client.send({
          type: C2S.GAME_INPUT,
          roomId: mp.roomId,
          input: { moveX: Number(moveX)||0, moveZ: Number(moveZ)||0, sprint: !!sprint, yaw },
        });
      };

      mp._applySnapshot = function({ playerObject, scene, cameraController }){
        const snap = mp.lastSnapshot;
        if (!snap || !scene) return;

        const youId = mp.youId || sessionStorage.getItem('mp_youId') || null;
        const players = snap.players || {};

        // local player position
        if (youId && players[youId] && playerObject?.position) {
          const p = players[youId];
          const pos = p.pos || {};
          playerObject.position.x = Number(pos.x) || 0;
          playerObject.position.y = Number(pos.y) || 2;
          playerObject.position.z = Number(pos.z) || 0;
        }

        // remotes
        for (const pid of Object.keys(players)) {
          if (pid === youId) continue;
          const ent = ensureRemoteMesh(scene, pid);
          const pos = players[pid]?.pos || {};
          ent.mesh.position.set(Number(pos.x)||0, Number(pos.y)||2, Number(pos.z)||0);
        }

        // cleanup remotes that disappeared
        for (const [pid, ent] of mp.remote) {
          if (!players[pid]) {
            try { scene.remove(ent.mesh); } catch(_) {}
            mp.remote.delete(pid);
          }
        }
      };
    })();

    // ---------------------------
    // Patch 3: MapLoader (fetch + ÏµúÏÜå Í≤ÄÏ¶ù)
    // ---------------------------
    async function loadMapJson(path){
      const url = `${path}?v=${Date.now()}`; // cache bust (old json Î∞©ÏßÄ)
      const res = await fetch(url, { cache: "no-store" });
      if(!res.ok) throw new Error(`Map fetch failed: ${res.status} ${res.statusText}`);
      const data = await res.json();

      if(!data?.meta?.mode) throw new Error("Invalid map: meta.mode missing");
      if(!Array.isArray(data.spawns)) throw new Error("Invalid map: spawns missing");
      if(!Array.isArray(data.zones)) throw new Error("Invalid map: zones missing");
      if(!Array.isArray(data.objects)) throw new Error("Invalid map: objects missing");
      if(!data?.world?.groundSize || data.world.groundSize.length !== 2) throw new Error("Invalid map: world.groundSize missing");

      return data;
    }

    // ---------------------------
    // Patch 3: SceneBuilder (JSON -> Three)
    // ---------------------------
    const MATERIAL_BY_TYPE = {
      ground: new THREE.MeshStandardMaterial({ color: 0xd6d6d6, roughness: 0.95, metalness: 0 }),
      wall:   new THREE.MeshStandardMaterial({ color: 0xb8b8b8, roughness: 0.95, metalness: 0 }),
      cover:  new THREE.MeshStandardMaterial({ color: 0x8f8f8f, roughness: 0.95, metalness: 0 }),
    };

    const ZONE_MAT = new THREE.MeshStandardMaterial({ color: 0x4fa3ff, transparent: true, opacity: 0.22, roughness: 1, metalness: 0 });
    const ZONE_EDGE = new THREE.LineBasicMaterial({ color: 0x4fa3ff, transparent: true, opacity: 0.9 });

    const TEAM_COLOR = {
      blue: 0x4fa3ff,
      red:  0xff5b5b
    };

    function makeGround(w, d){
      const geo = new THREE.PlaneGeometry(w, d);
      const mesh = new THREE.Mesh(geo, MATERIAL_BY_TYPE.ground);
      mesh.rotation.x = -Math.PI / 2;
      mesh.receiveShadow = true;
      return mesh;
    }

    function makeBox(type, size, pos){
      const [sx, sy, sz] = size;
      const geo = new THREE.BoxGeometry(sx, sy, sz);
      const mat = MATERIAL_BY_TYPE[type] || MATERIAL_BY_TYPE.cover;
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(pos[0], pos[1], pos[2]);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    }

    function makeZoneCircle(radius, pos){
      const geo = new THREE.CylinderGeometry(radius, radius, 0.2, 48, 1, true);
      const mesh = new THREE.Mesh(geo, ZONE_MAT);
      mesh.position.set(pos[0], 0.1, pos[2]);
      mesh.receiveShadow = false;
      mesh.castShadow = false;

      // edge
      const points = [];
      const seg = 64;
      for(let i=0;i<=seg;i++){
        const a = (i/seg) * Math.PI * 2;
        points.push(new THREE.Vector3(Math.cos(a)*radius, 0.12, Math.sin(a)*radius));
      }
      const edgeGeo = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(edgeGeo, ZONE_EDGE);
      line.position.set(pos[0], 0, pos[2]);

      const g = new THREE.Group();
      g.add(mesh);
      g.add(line);
      return g;
    }

    function makeSpawnMarker(team, pos){
      const color = TEAM_COLOR[team] ?? 0xffffff;
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.7, metalness: 0.05 });
      const baseGeo = new THREE.CylinderGeometry(2.2, 2.2, 0.25, 24);
      const base = new THREE.Mesh(baseGeo, mat);
      base.position.set(pos[0], 0.13, pos[2]);

      const coneGeo = new THREE.ConeGeometry(1.5, 3.6, 16);
      const cone = new THREE.Mesh(coneGeo, mat);
      cone.position.set(pos[0], 2.2, pos[2]);

      const g = new THREE.Group();
      g.add(base);
      g.add(cone);
      return g;
    }

    function makePlayerDummy(pos){
      // "Ïä§Ìè∞ Í∞ÄÎä•Ìïú ÏÉÅÌÉú" ÌôïÏù∏Ïö© ÎçîÎØ∏ Ï∫êÎ¶≠ÌÑ∞ (Ï°∞Ïûë ÏóÜÏùå)
      const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9, metalness: 0 });
      const geo = new THREE.CapsuleGeometry(0.55, 0.9, 6, 12);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(pos[0], pos[1], pos[2]);
      mesh.castShadow = true;
      return mesh;
    }

    function buildScene(map){
      const scene = new THREE.Scene();
      const collisionWorld = new CollisionWorld();
      scene.background = new THREE.Color(0x0b0f17);

      // lights (Î∞ùÍ≤å)
      const amb = new THREE.AmbientLight(0xffffff, map.world?.ambientLight ?? 0.75);
      scene.add(amb);

      const dlPos = map.world?.dirLight?.pos ?? [80, 140, 60];
      const dl = new THREE.DirectionalLight(0xffffff, map.world?.dirLight?.intensity ?? 1.1);
      dl.position.set(dlPos[0], dlPos[1], dlPos[2]);
      dl.castShadow = true;
      dl.shadow.mapSize.set(1024, 1024);
      dl.shadow.camera.near = 1;
      dl.shadow.camera.far = 400;
      dl.shadow.camera.left = -160;
      dl.shadow.camera.right = 160;
      dl.shadow.camera.top = 160;
      dl.shadow.camera.bottom = -160;
      scene.add(dl);

      const [gw, gd] = map.world.groundSize;
      scene.add(makeGround(gw, gd));

      // objects
      for(const obj of map.objects){
        if(obj.shape === "box"){
          scene.add(makeBox(obj.type, obj.size, obj.pos));
          // Collision: default to collidable for any solid box except floor/ground.
          // (Maps may use different type names; safer to opt-out only for floor-like objects.)
          const t = (obj.type || "").toLowerCase();
          const nonSolid = (t === "floor" || t === "ground" || t === "deco" || t === "decor" || t === "sky");
          const collidable = (obj.collision === false) ? false : !nonSolid;

          if (collidable) {
            collisionWorld.addCenteredBox(obj.type, obj.size, obj.pos);
          }
        }
      }

      // zones (ÌëúÏãúÏö©)
      const zones = [];
      for(const z of map.zones){
        if(z.shape === "circle"){
          const g = makeZoneCircle(z.radius ?? 20, z.pos);
          scene.add(g);
          zones.push({ id: z.id, pos: z.pos, radius: z.radius ?? 20 });
        }
      }

      // spawns (ÌëúÏãúÏö©)
      const spawns = {};
      for(const s of map.spawns){
        const team = s.team;
        spawns[team] = s;
        scene.add(makeSpawnMarker(team, s.pos));
      }

      return { scene, zones, spawns, collisionWorld };
    }

    // ---------------------------
    // Renderer / Camera
    // ---------------------------
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.rotation.order = "YXZ";

    // Patch 4 managers
    const settingsStore = new SettingsStore();
    const inputManager = new InputManager({ domElement: renderer.domElement, settingsStore });

    

    // Patch 6-1a/b: Build session profile (class + inventory) from lobby selection
    const __savedClass = (()=>{ try{ return localStorage.getItem(CLASS_KEY); }catch(e){ return null; } })();
    const __classId = normalizeClassId(__savedClass || "assault");
    window.playerProfile = {
      classId: __classId,
      className: (CLASSES[__classId] || CLASSES.assault).name,
      inventory: initInventoryForClass(__classId),
      activeSlot: { type:"secondary", index:0 },
      team: "blue",
    };

    // Patch 8-1PRO: default team is blue unless changed in console
    window.setTeam = function(team){
      const t = String(team||"").toLowerCase();
      window.playerProfile.team = (t === "red" || t === "t") ? "red" : "blue";
      console.log("[Strikegy] Team set to:", window.playerProfile.team);
    };

        // Patch 9-4D: Battlefield-like floating reward texts
        class RewardFloat {
          constructor(root){
            this.root = root;
            this.items = [];
            this.pending = new Map();
            this._flushLeft = 0;
          }
          _labelFor(reason){
            const r = String(reason||"");
            if(r === 'kill') return 'KILL';
            if(r === 'zone_capture') return 'CAPTURE';
            if(r === 'zone_tick') return 'CAPTURING';
            if(r === 'damage_head') return 'HIT (HS)';
            if(r === 'damage') return 'HIT';
            return '';
          }
          push({amount, reason}){
            const a = Math.round(Number(amount)||0);
            if(!a) return;
            // ignore passive ticks to keep the feed clean
            if(String(reason||"") === 'passive') return;
            const label = this._labelFor(reason);
            const key = label || String(reason||"reward");
            const cur = this.pending.get(key) || { amount:0, label };
            cur.amount += a;
            this.pending.set(key, cur);
            this._flushLeft = 0.18;
          }
          _flush(){
            if(!this.root) return;
            const now = performance.now();
            for(const v of this.pending.values()){
              const line = document.createElement('div');
              line.className = 'rewardFloat__line';
              const sign = v.amount >= 0 ? '+' : '';
              const label = v.label ? ` ${v.label}` : '';
              line.textContent = `${sign}$${Math.abs(v.amount)}${label}`;
              line.dataset.t0 = String(now);
              this.root.appendChild(line);
              // initial position (stack)
              const idx = this.items.length;
              this.items.push({ el: line, life: 0, y: -6 - idx*18 });
              requestAnimationFrame(()=> line.classList.add('show'));
            }
            this.pending.clear();
          }
          update(dt){
            if(!this.root) return;
            if(this._flushLeft > 0){
              this._flushLeft -= dt;
              if(this._flushLeft <= 0){
                this._flush();
              }
            }
            // animate existing items upward + fade
            for(let i=this.items.length-1;i>=0;i--){
              const it = this.items[i];
              it.life += dt;
              const t = it.life;
              it.y -= 18 * dt;
              const alpha = Math.max(0, Math.min(1, (t < 0.12 ? t/0.12 : (t > 1.05 ? (1.35 - t)/0.30 : 1))));
              if(it.el){
                it.el.style.opacity = String(alpha);
                it.el.style.transform = `translate(-50%, ${it.y}px) scale(${0.98 + Math.min(0.02, t*0.03)})`;
              }
              if(t >= 1.35){
                try{ it.el?.remove?.(); }catch(e){}
                this.items.splice(i,1);
              }
            }
          }
        }

        let rewardFloat = null;
// Patch 6-2a: Economy manager init
    economyManager = new EconomyManager(window.playerProfile);
    economyManager.initOnGameStart();

    // Patch 9-4D: reward floating texts
    rewardFloat = new RewardFloat(document.getElementById('rewardFloat'));
    economyManager.onReward = (ev)=>{ try{ rewardFloat?.push(ev); }catch(e){} };

    window.__strikegyUILock = window.__strikegyUILock || { inventory:false, shop:false };

// Patch 4.3: Mobile HUD (joystick + buttons + swipe look)
    const mobileHUD = new MobileHUD({ root: document.body, input: inputManager, presetGetter: ()=>settingsStore.controlPreset });

    // Patch 8-0X: Combat overlay UI (HP / damage / death / respawn)
    const combatUI = new CombatOverlayUI({ root: document.body });
    window.combatUI = combatUI;
    // Patch 8-2: Damage system registry (for bots/remote players + headshots)
    const damageSystem = new DamageSystem({ combatUI });
    window.damageSystem = damageSystem;


    // Patch 8-1: Minimap UI (player + zones)
    const __modeForMinimap = (typeof getSelectedMode === "function") ? getSelectedMode() : "zone";
// Patch 8-1E: tighten minimap range + per-mode scaling (Frontline zoom-in)
const __minimapCfgByMode = {
  zone:      { range: 45, uiScale: 1.0 },
  conquest:  { range: 52, uiScale: 1.0 },
  frontline: { range: 34, uiScale: 1.15 },
  bomb:      { range: 38, uiScale: 1.0 },
};
const __mmCfg = __minimapCfgByMode[__modeForMinimap] || __minimapCfgByMode.zone;
const minimap = new MinimapUI(document.getElementById("minimapCanvas"), __mmCfg);
    window.minimap = minimap;


    // Patch 8-0PRO: TEMP Health/Death/Respawn (grenade damage test loop)
    let playerHP = 100;
    let playerHPMax = 100;
    let playerDead = false;
    // Patch 9-4F: simple corpse marker (non-blocking, not targetable)
    let deadBodyMesh = null;
    let respawnLeft = 0;
    // Patch 8-2PRO: Bandage (ü©π) - all players start with 1 each life; medic unlimited
    let bandageCount = 1;          // for non-medic
    let bandageHealing = false;
    let bandageHealRate = 0;       // HP per second
    let bandageHealStopOnDamage = true;

    function isMedic(){
      return (window.playerProfile?.classId === "medic");
    }
    function getBandageCount(){
      return isMedic() ? Infinity : bandageCount;
    }
    function syncBandageUI(){
      try{
        window.combatUI?.setBandageCount?.(getBandageCount());
        const canUse = (!playerDead) && (playerHP < playerHPMax) && (!bandageHealing) && (isMedic() || bandageCount > 0);
        window.combatUI?.setBandageHintActive?.(!!canUse);
      }catch{}
    }
    function stopBandageHealing(){
      if(!bandageHealing) return;
      bandageHealing = false;
      bandageHealRate = 0;
      syncBandageUI();
    }
    function startBandageHealing(){
      if(playerDead) return;
      try{
        const myTeam = String(window.playerProfile?.team || 'blue').toLowerCase();
        const st = String(sourceTeam || '').toLowerCase();
        if(st && myTeam && st === myTeam) return; // no friendly damage
      }catch{}
      if(playerHP >= playerHPMax) return;
      if(bandageHealing) return;
      if(!isMedic()){
        if(bandageCount <= 0) return;
        bandageCount -= 1;
      }
      bandageHealing = true;
      bandageHealRate = 15 + Math.random()*6; // 15~21 per sec
      syncBandageUI();
    }


    function setHP(cur){
      playerHP = Math.max(0, Math.min(playerHPMax, Number(cur)));
      window.combatUI?.setHP?.(playerHP, playerHPMax);
      syncBandageUI();
    }

    function getDefaultSpawn(){
      const sp = current?.spawns || null;

      // Team defaults to blue unless changed in console via window.setTeam("red")
      const team = (window.playerProfile?.team || "blue");
      const norm = (t)=> {
        const x = String(t||"").toLowerCase();
        if(x === "red" || x === "t") return "red";
        return "blue";
      };
      const key = norm(team);

      // Hotfix 9-4E.2: Conquest defender team spawns behind the current frontline zone.
      // Rule: if frontline zone is B, defender spawns at C; if frontline is last, spawn at last.
      try{
        if(String(mode||'').toLowerCase() === 'conquest'){
          const ms = window.modeSystem;
          const def = String(ms?.conquestDefender || 'red').toLowerCase();
          if(key === def){
            const order = ms?.order;
            if(Array.isArray(order) && order.length){
              const fi = (ms?.conquestFrontIndex ?? 0) | 0;
              const idx = Math.min(fi + 2, order.length - 1);
              const zid = order[idx];
              const zones = (window._map?.zones || current?.map?.zones || current?.zones || []);
              const z = (zones || []).find(zz => String(zz?.id ?? '').toUpperCase() === String(zid).toUpperCase());
              if(z){
                const p = z.pos ?? z.position ?? [0,2,0];
                const x = Number(p[0] ?? p.x ?? 0) || 0;
                const y = Number(p[1] ?? p.y ?? 2) || 2;
                const zc = Number(p[2] ?? p.z ?? 0) || 0;
                return { pos: [x, y, zc], yaw: 0 };
              }
            }
          }
        }
      }catch(e){ /* fall back to spawn table */ }

      // current.spawns is a map: { blue: spawnObj, red: spawnObj, ... }
      const pickOne = (k)=> (sp && sp[k]) ? sp[k] : null;

      // Team spawn first, then sensible fallbacks
      return pickOne(key) || pickOne(key === "blue" ? "red" : "blue")
        || pickOne("ct") || pickOne("t") || pickOne("all") || null;
    }

    function killPlayer(){
      if(playerDead) return;
      playerDead = true;
      try{ modeSystem?.onDeath?.(window.playerProfile?.team || 'blue'); }catch{}
      // Patch 9-1: Zone tickets
      try{ modeSystem?.onDeath?.(window.playerProfile?.team || "blue"); }catch(e){}

      respawnLeft = 5.0;
      stopBandageHealing();

      // Patch 7-4B+: class-item ammo/mag resets immediately on death (per design)
      try{ classItemSystem?.resetOnDeath?.(); }catch{}

      // Patch 8-4A2: reset ALL weapon magazine/reserve states on death.
      // (Per design: death should wipe per-life ammo state, not carry partial mags.)
      try{ weaponSystem?.resetAllAmmoFull?.(); }catch{}

      // UI
      window.combatUI?.setDead?.({ killerText: "KILLED" });
      window.combatUI?.setRespawning?.(Math.ceil(respawnLeft));

      // Patch 9-4F: simple corpse marker (doesn't block LOS)
      try{
        if(deadBodyMesh){
          current.scene?.remove?.(deadBodyMesh);
          deadBodyMesh.geometry?.dispose?.();
          deadBodyMesh.material?.dispose?.();
          deadBodyMesh = null;
        }
        const geo = new THREE.BoxGeometry(0.35, 0.12, 1.15);
        const mat = new THREE.MeshBasicMaterial({ color: 0x111111, transparent: true, opacity: 0.55 });
        deadBodyMesh = new THREE.Mesh(geo, mat);
        deadBodyMesh.name = "corpse_player";
        deadBodyMesh.userData.ignoreLOS = true;
        const p = playerObject?.position;
        if(p){
          deadBodyMesh.position.set(p.x, Math.max(0.06, (p.y ?? 0) + 0.06), p.z);
        }
        deadBodyMesh.rotation.y = (playerController?.yaw ?? 0);
        current.scene?.add?.(deadBodyMesh);
      }catch(e){}

      // minimal input cancel
      mouseLeftDown = false;
      mouseRightDown = false;
    }

    
// Patch 8-1PRO: respawn inventory reset rules
function resetInventoryForRespawn(){
  const p = window.playerProfile;
  if(!p || !p.inventory) return;

  const inv = p.inventory;

  // Keep melee + class items
  const keepMelee = inv.melee;
  const keepClassItems = Array.isArray(inv.classItems) ? inv.classItems.slice() : [null, null];

  // Reset everything else (keep default pistol)
  inv.primary = null;
  inv.secondary = "pistol1";
  inv.grenades = [null, null, null];

  inv.melee = keepMelee;
  inv.classItems = keepClassItems;

  // Reset per-life class-item state that has ammo/mag semantics
  // Bandage/AmmoBag are infinite => nothing to reset for them.
  if(!p.classItemState) p.classItemState = {};
  const s = p.classItemState;
  // ammo pools used by some class items
  if(typeof s.panzerAmmo === "number") s.panzerAmmo = 2;
  if(typeof s.smokeLauncherAmmo === "number") s.smokeLauncherAmmo = 4;
  // give-limits reset per life
  s.medicGiven = {};
  s.supportGiven = {};

  // Force active slot to default pistol
  p.activeSlot = { type:"secondary", index:0 };

  // Let switch manager resync weapon system on next update
  weaponSwitchManager?.ensureActiveSlot?.();
  weaponSwitchManager?.switchToSecondary?.();
}
function respawnPlayer(){
      playerDead = false;

	      // Patch 9-4F: remove corpse marker on respawn
	      try{
	        if(deadBodyMesh){
	          current.scene?.remove?.(deadBodyMesh);
	          deadBodyMesh.geometry?.dispose?.();
	          deadBodyMesh.material?.dispose?.();
	          deadBodyMesh = null;
	        }
	      }catch(e){}

      // Inventory reset at respawn (keep melee + class items; keep default pistol)
      resetInventoryForRespawn();

      // Bandage reset: 1 per life (medic is infinite)
      bandageCount = 1;
      stopBandageHealing();

      setHP(playerHPMax);

      const sp = getDefaultSpawn();
      if(sp) initPlayerFromSpawn(sp);

      window.combatUI?.respawnFlash?.();
      window.combatUI?.setAlive?.();
    }

    // Explosion damage: distance falloff, local player only (temporary)
    function applyExplosionDamageToLocal({ pos, radius, max, min, sourceTeam=null }){
      // Teamkill/self-damage OFF by spec.
      // - Local player: no self-damage from own throwables.
      // - Bots: only enemies take damage.
      const srcTeam = String(sourceTeam || (window.playerProfile?.team || 'blue')).toLowerCase();
      const ds = window.damageSystem;
      if(!pos || !radius || !ds) return;

      // Apply to damageables (bots etc.)
      try{
        for(const ent of ds._byId?.values?.() || []){
          if(!ent || !ent.alive) continue;
          const tTeam = String(ent.team || 'neutral').toLowerCase();
          if(tTeam === srcTeam) continue; // no team damage
          const mpos = ent.mesh?.position;
          if(!mpos) continue;
          const d = mpos.distanceTo(pos);
          if(d > radius) continue;
          const t = 1 - (d / Math.max(0.001, radius)); // 1..0
          const dmg = Math.round((min ?? 0) + ((max ?? 0) - (min ?? 0)) * t);
          if(dmg <= 0) continue;
          const res = ds.applyDamage(ent.id, dmg, { weaponId: "grenade", sourceTeam: srcTeam, headshot: false });
          try{ economyManager?.rewardDamage?.(dmg, false); }catch{}
          if(res?.killed){
            try{ economyManager?.rewardKill?.(); }catch{}
            try{ modeSystem?.onDeath?.(ent.team); }catch{}
          }
        }
      }catch(e){ console.warn(e); }
    }

    
    // Patch 8-2: Bullet damage for local player (bots will call this later)
    function applyBulletDamageToLocal({ amount, headshot=false, weaponId=null, sourceTeam=null, sourceId=null } = {}){
      if(playerDead) return;
      const base = Math.max(0, Number(amount) || 0);
      const dmg = Math.round(base);
      const ratio = Math.min(1, Math.max(0, dmg / playerHPMax));
      window.combatUI?.flashDamage?.(ratio);
      stopBandageHealing();
      setHP(playerHP - dmg);
      // Economy for bots: bot gains money for damage dealt (and kill if applicable)
      try{
        if(sourceId && botManager?.bots){
          const b = botManager.bots.find(x=>String(x.id)===String(sourceId));
          b?.economy?.rewardDamage?.(dmg, !!headshot);
        }
      }catch(e){}

      if(playerHP <= 0){
        try{
          if(sourceId && botManager?.bots){
            const b = botManager.bots.find(x=>String(x.id)===String(sourceId));
            b?.economy?.rewardKill?.();
          }
        }catch(e){}
        killPlayer();
      }
    }
    window.applyBulletDamageToLocal = applyBulletDamageToLocal;

// initial sync
    setHP(playerHP);
    syncBandageUI();


    
    // Patch 6-1b: Inventory modal + üéí button
    const inventoryModal = new InventoryModal({
      root: document.body,
      input: inputManager,
      settingsStore,
      mobileHUD,
      getProfile: ()=>window.playerProfile
    });

    // Patch 6-2b: Shop system + modal
    const shopSystem = new ShopSystem({ getProfile: ()=>window.playerProfile, getEconomy: ()=>economyManager });
    // --- Shop cart button (mobile UI). Always define to avoid ReferenceError.

    const shopCartBtn = document.getElementById("shopCartBtn") || (() => {

      const b = document.createElement("button");

      b.id = "shopCartBtn";

      b.type = "button";

      b.textContent = "üõí";

      b.setAttribute("aria-label", "ÏÉÅÏ†ê");

      document.body.appendChild(b);

      return b;

    })();


    
    // --- Money HUD (always define)
    const moneyHUD = document.getElementById("moneyHUD") || (() => {
      const d = document.createElement("div");
      d.id = "moneyHUD";
      d.textContent = "$0";
      document.body.appendChild(d);
      return d;
    })();
    window.moneyHUD = moneyHUD;
const shopModal = new ShopModal({
      root: document.body,
      input: inputManager,
      settingsStore,
      mobileHUD,
      getProfile: ()=>window.playerProfile,
      shopSystem
    });
    // expose for debugging
    window.shopModal = shopModal;

    shopCartBtn.addEventListener('click', (e)=>{ e.preventDefault(); shopModal.toggle(); });


    const invBagBtn = document.createElement("button");
    invBagBtn.id = "invBagBtn";
    invBagBtn.type = "button";
    invBagBtn.textContent = "üéí";
    invBagBtn.title = "Inventory (I)";
    invBagBtn.addEventListener("click", (e)=>{
      e.preventDefault();
      inventoryModal.toggle();
    });
    document.body.appendChild(invBagBtn);

    function updateInvBagVisibility(){
      const p = settingsStore.controlPreset;
      const show = (p === "mobile" || p === "mobile_kb");
      invBagBtn.style.display = show ? "block" : "none";
      shopCartBtn.style.display = show ? "block" : "none";
      moneyHUD.style.display = "block";
    }

    // Key bindings (PC + mobile_kb)
    window.addEventListener("keydown", (e)=>{
      if(e.code === "KeyB"){
        if(e.repeat) return;
        const tag = document.activeElement?.tagName;
        if(tag === "INPUT" || tag === "TEXTAREA") return;
        try{ shopModal.toggle(); }catch{}
        e.preventDefault();
      }else if(e.code === "KeyI"){
        if(e.repeat) return;
        const tag = document.activeElement?.tagName;
        if(tag === "INPUT" || tag === "TEXTAREA") return;
        inventoryModal.toggle();
        e.preventDefault();
      }else if(e.code === "KeyC"){
        if(e.repeat) return;
        const tag = document.activeElement?.tagName;
        if(tag === "INPUT" || tag === "TEXTAREA") return;
        // Use bandage if HP < 100
        startBandageHealing();
        e.preventDefault();
      }else if(e.code === "Escape"){
        if(inventoryModal.isOpen()){
          inventoryModal.close();
          e.preventDefault();
        }
      }
    });

// Patch 4: PC ÌîÑÎ¶¨ÏÖãÏù¥Î©¥ Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶≠ÏúºÎ°ú Ìè¨Ïù∏ÌÑ∞ÎùΩ
    renderer.domElement.addEventListener("click", () => {
      settingsStore.refresh();
      if(settingsStore.controlPreset !== "pc") return;
      if(document.pointerLockElement !== renderer.domElement){
        renderer.domElement.requestPointerLock?.();
      }
    });

    let cameraController = null;
    let playerController = null;
    let collisionWorld = null;
    let playerObject = null;
    const clock = new THREE.Clock();


    let current = { scene: null, zones: [], spawns: {} };
  // Patch 5A (PC): weapons + decals
  let weaponSystem = null;
  let soundSystem = null;
  let weaponSwitchManager = null;
  let muzzleFlash = null;
  let casingSystem = null;
  let decalManager = null;
  let collidableMeshes = [];
  let mouseLeftDown = false;
  let mouseRightDown = false;
  let lastFov = null;
    // Patch 7-2B: scope overlay DOM cache
    let scopeOverlayEl = null;
    let binoOverlayEl = null;
    let crosshairEl = null;

        let smokeOverlayEl = null;
    let flashOverlayEl = null;

    // Patch 7-4A: Throwables system
    let throwablesSystem = null;
    let prevGrenadeHold = false;
    let prevClassUse = false;

    // Patch 8-3A: Bot manager (movement + minimap markers)
    let botManager = null;

    // Patch 9-1: Mode rules + capture system
    let modeSystem = null;
    let _modeUiAcc = 0;
let _roundShown = false;

    // Patch 7-2B: recoil presets (radians)
    const deg = (d)=> (d * Math.PI / 180);
    function recoilPresetFor(id){
      const s = String(id||"").toLowerCase();
      if(s.startsWith('sr'))  return { pitch: deg(1.35), yaw: deg(0.18), retHip: 10, retAds: 14 };
      if(s.startsWith('dmr')) return { pitch: deg(0.85), yaw: deg(0.18), retHip: 12, retAds: 16 };
      if(s.startsWith('sg'))  return { pitch: deg(1.10), yaw: deg(0.35), retHip: 11, retAds: 14 };
      if(s.startsWith('lmg')) return { pitch: deg(0.65), yaw: deg(0.35), retHip: 11, retAds: 15 };
      if(s.startsWith('smg')) return { pitch: deg(0.35), yaw: deg(0.28), retHip: 14, retAds: 18 };
      if(s.startsWith('ar'))  return { pitch: deg(0.45), yaw: deg(0.22), retHip: 13, retAds: 17 };
      if(s.startsWith('mp'))  return { pitch: deg(0.40), yaw: deg(0.30), retHip: 14, retAds: 18 };
      // pistols
      return { pitch: deg(0.55), yaw: deg(0.20), retHip: 13, retAds: 17 };
    }

    // Patch 7-4A: grenade HUD names
    const GRENADE_LABEL = {
      frag:  "üí• Í≥†Ìè≠ ÏàòÎ•òÌÉÑ",
      smoke: "‚òÅÔ∏è Ïó∞ÎßâÌÉÑ",
      flash: "‚ú® ÏÑ¨Í¥ëÌÉÑ",
      impact:"üí£ Ï∂©Í≤© ÏàòÎ•òÌÉÑ",
    };
    function grenadeHudName(id){
      const k = String(id||"");
      return GRENADE_LABEL[k] || "Ìà¨Ï≤ôÎ¨¥Í∏∞";
    }
    
    function initPlayerFromSpawn(spawn){
      const p = spawn?.pos ?? [0,2,0];
      const yaw = spawn?.yaw ?? 0;

      // Í∏∞Ï°¥ ÌîåÎ†àÏù¥Ïñ¥ Ï†úÍ±∞
      if(playerObject && playerObject.parent) playerObject.parent.remove(playerObject);
      if(camera.parent) camera.parent.remove(camera);

      // ÏÉà ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ± + Ïπ¥Î©îÎùº Î∂ÄÏ∞©
      playerObject = makePlayerDummy(p);
      current.scene.add(playerObject);
      playerObject.add(camera);
      camera.position.set(0, 1.6, 0);

      // Ïª®Ìä∏Î°§Îü¨ ÏÉùÏÑ±/Í∞±Ïã†
      settingsStore.refresh();
      cameraController = new CameraController({ playerObject, camera, settingsStore });
      cameraController.setFromSpawnYawDegrees(-90); // Patch 4A: Í≥†Ï†ï Ï¥àÍ∏∞ yaw


      playerController = new PlayerController({ playerObject });
      playerController.teleportTo(p);
    }

    function showError(path, err){
      const overlay = document.getElementById("overlayError");
      document.getElementById("failPath").textContent = path;
      document.getElementById("failLog").textContent = String(err?.stack || err?.message || err);
      overlay.style.display = "flex";
    }

    function hideError(){
      document.getElementById("overlayError").style.display = "none";
    }

    async function boot(){
      const mode = getSelectedMode();
      const path = resolveMapPath();

      document.getElementById("modeLabel").textContent = mode;
      document.getElementById("mapLabel").textContent = path;

      try{
        hideError();
        document.getElementById("status").textContent = "Îßµ JSON Î°úÎìú Ï§ë‚Ä¶";

        const map = await loadMapJson(path);
        // Hotfix 9-4E.2: expose map for systems that need it outside boot() scope.
        window._map = map;

        // ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
        const [gw, gd] = map.world.groundSize;
        document.getElementById("worldLabel").textContent = `${gw} x ${gd}`;
        document.getElementById("zonesLabel").textContent = `${map.zones.length}`;

        document.getElementById("status").textContent = "Ïî¨ ÎπåÎìú Ï§ë‚Ä¶";
        current = buildScene(map);
        collisionWorld = current.collisionWorld;

        // Patch 8-1: minimap bounds + zones (neutral for now)
        try{
          window.minimap?.setBoundsFromGroundSize?.(map.world?.groundSize);
          window.minimap?.setZones?.(map.zones);
          // Patch 8-1C: draw inner/outer walls on minimap (type: "wall")
          window.minimap?.setWalls?.(map.objects);
        }catch(e){ /* ignore minimap failures */ }

        // Patch 9-1: Mode rules init (Zone / Conquest / Frontline)
        try{
          modeSystem = new ModeSystem({ mode, zones: map.zones, opts: { ticketsBlue:200, ticketsRed:200, conquestTimeLimit: 15*60, frontlineSwapSec: 5*60, frontlineTimeLimit: 15*60 } });
          window.modeSystem = modeSystem;
          // initial HUD render
          window.combatUI?.setModeState?.(modeSystem.getUIState({ playerPos: playerObject?.position || null }));
          if(!_roundShown && modeSystem?.roundEnded){
            _roundShown = true;
            window.combatUI?.showRoundResult?.(modeSystem?.getRoundResult?.());
          }
        }catch(e){ console.warn("ModeSystem init failed:", e); }



        // Patch 4: ÌîåÎ†àÏù¥Ïñ¥/Ïπ¥Î©îÎùº Ï¥àÍ∏∞Ìôî (BLUE Ïä§Ìè∞, ÏóÜÏúºÎ©¥ Ï≤´ Ïä§Ìè∞)
        const blue = current.spawns.blue ?? map.spawns[0];
        initPlayerFromSpawn(blue);

        // Patch 8-3A: Bots (spawn at team spawns, roam between zones)
        try{
          if(botManager){
            botManager.clear?.();
          }
          const _botAim = new THREE.Vector3();
          botManager = new BotManager({
            scene: current.scene,
            collisionWorld: collisionWorld,
            map,
            mode,
            difficultyId: settingsStore.botDifficulty,
            playerBaseSpeed: (playerController?.baseSpeed ?? 6),
            // Default bot counts (5v5 feel: player+4 vs 5)
            botCountBlue: 4,
            botCountRed: 5,
            getPlayerPosition: ()=> playerObject?.position || null,
            getPlayerTeam: ()=> (window.playerProfile?.team || 'blue'),
            damageSystem: window.damageSystem,
            getPlayerAimPosition: ()=>{
              const p = playerObject?.position;
              if(!p) return null;
              // Patch 9-4F: dead players are not targetable (prevents bots shooting corpse)
              if(playerDead || playerHP <= 0) return null;
              // aim for upper torso/head area
              return _botAim.set(p.x, (p.y ?? 0) + 1.45, p.z);
            },
            getCollidables: ()=> collidableMeshes,
            onShootPlayer: ({ amount, headshot=false, weaponId=null, sourceTeam=null, sourceId=null }={})=>{
              if(playerDead) return;
              try{ window.applyBulletDamageToLocal?.({ amount, headshot, weaponId, sourceTeam, sourceId }); }catch{}
            },
          });
          botManager.init?.();
          window.botManager = botManager;
        }catch(e){ console.warn("[Strikegy] BotManager init failed", e); }


        
    // Patch 5A: gather collidables (anything that isn't the player/camera)
    collidableMeshes = [];
    current.scene.traverse((obj)=>{
      if(obj && obj.isMesh){
        // ignore decals/hud helpers
        if(obj.name && (obj.name.startsWith("decal_") || obj.name.startsWith("corpse_"))) return;
        collidableMeshes.push(obj);
      }
    });
    decalManager = new DecalManager(current.scene);
    soundSystem = new SoundSystem();
    window.soundSystem = soundSystem;
    // WebAudio unlock: browsers block sound until a user gesture
    window.addEventListener('mousedown', ()=> soundSystem?.unlock?.(), { once:true });
    window.addEventListener('touchstart', ()=> soundSystem?.unlock?.(), { once:true, passive:true });
    muzzleFlash = new MuzzleFlash(current.scene, camera);
    // Patch 7-3C: casings/shells (pooled)
    casingSystem = new CasingSystem(current.scene, camera, { maxCount: 80, lifeSeconds: 30 });
    weaponSystem = new WeaponSystem({
      camera: camera,
      scene: current.scene,
      getCollidables: ()=> collidableMeshes,
      getDamageables: ()=> window.damageSystem?.getDamageableMeshes?.() || [],
      onWallHit: (hit)=> decalManager.add(hit),
      // Patch 8-2: hitscan -> damageable entity hit
      onEntityHit: (hit, weapon)=>{
        try{
          const ds = window.damageSystem;
          const ent = ds?.getEntityFromHitObject?.(hit?.object);
          if(!ent || !ent.alive) return;
          const myTeam = window.playerProfile?.team || "blue";
          if(ent.team && ent.team === myTeam) return; // no friendly fire (for now)

          const isHead = ds.isHeadshot(hit, ent);
          const base = Number(weapon?.damage) || 25;
          const mult = isHead ? (Number(weapon?.headshotMult) || 1.5) : 1;
          const dmg = Math.round(base * mult);

          const res = ds.applyDamage(ent.id, dmg, { weaponId: weapon?.id || null, sourceTeam: myTeam, headshot: isHead });
          // Economy: damage pays per damage; headshot damage pays 2x
          try{ economyManager?.rewardDamage?.(dmg, isHead); }catch{}
          if(res?.killed){
            try{ economyManager?.rewardKill?.(); }catch{}
            try{ modeSystem?.onDeath?.(ent.team); }catch{}
          }
          // Lightweight feedback for debugging
          if(res?.ok){
            window.combatUI?.hitMarker?.({ killed: !!res.killed, headshot: !!res.headshot });
            console.log(`[DMG] hit ${ent.id} ${isHead ? "HEAD" : "BODY"} -${dmg} (hp ${ent.hp}/${ent.maxHp})`);
          }
        }catch(e){ console.warn(e); }
      },
      onSound: (name)=> soundSystem.play(name),
      onEject: (payload)=>{
        // SR ejects on bolt timing; others immediate.
        casingSystem?.spawn?.({ mode: payload?.mode || "", weaponId: payload?.weaponId || "" });
      },
      // Patch 7-2B: muzzle flash + recoil kick
      onShot: (payload)=>{
        muzzleFlash.spawn();
        if(!cameraController) return;
        const wid = payload?.weaponId || weaponSystem?.currentId;
        const isADSNow = !!(payload?.isADS ?? weaponSystem?.isADS);
        const p = recoilPresetFor(wid);
        // ADS reduces recoil
        const mul = isADSNow ? 0.7 : 1.0;
        // yaw kick randomizes direction
        const yawKick = (Math.random()*2-1) * p.yaw * mul;
        cameraController.addRecoil(p.pitch * mul, yawKick);
      },
    });
    // Patch 6-3: weapon/slot switching manager (guns + grenades + class items + melee)
    weaponSwitchManager = new WeaponSwitchManager({
      profile: window.playerProfile,
      weaponSystem,
      onMelee: ()=>{
        soundSystem?.play?.("swap"); // placeholder SFX
        window.combatUI?.meleeSwing?.();
      },
    });
    weaponSwitchManager.ensureActiveSlot?.();
    // sync to current slot
    weaponSwitchManager.togglePrimarySecondary?.(); // will settle to owned slot

	    // Patch 7-2A: smooth ADS FOV (initialize)
	    lastFov = camera.fov;

            // Patch 7-2B / 7-4A: cache overlay elements
            scopeOverlayEl = document.getElementById('scopeOverlay');
            binoOverlayEl = document.getElementById('binoOverlay');
            crosshairEl = document.getElementById('crosshair');
            smokeOverlayEl = document.getElementById('smokeOverlay');
            flashOverlayEl = document.getElementById('flashOverlay');

            // Patch 7-4A: throwables system
            throwablesSystem = new ThrowablesSystem({
              camera,
              scene: current.scene,
              getCollidables: ()=> collidableMeshes,
              getPlayerPosition: ()=> (playerObject?.position ? playerObject.position : null),
              getPlayerTeam: ()=> (window.playerProfile?.team || "blue"),
              onSound: (name)=> soundSystem?.play?.(name),
              onCameraKick: (pitch, yaw)=> cameraController?.addRecoil?.(pitch, yaw),
              onLookLock: (sec)=> inputManager?.setLookLocked?.(sec),
              isMobile: (typeof window!=='undefined' && !!window.__isMobile) ? true : undefined,
              onDamage: (payload)=> applyExplosionDamageToLocal(payload),
              onEffect: (payload)=> { try{ window.botManager?.applyAoEEffect?.(payload); }catch(e){} },
              onOverlay: ({ smoke, flash })=>{
                // Smoke: blur + light desaturation tint
                if(smokeOverlayEl){
                  // Dense smoke: near-opaque inside
                  const o = Math.min(0.985, smoke * 0.985);
                  smokeOverlayEl.style.opacity = String(o);
                  // backdropFilter is expensive on mobile; keep it mild
                  const isM = (typeof window!=='undefined' && !!window.__isMobile);
                  const blur = isM ? (smoke * 8).toFixed(1) : (smoke * 18).toFixed(1);
                  smokeOverlayEl.style.backdropFilter = `blur(${blur}px)`;
                  smokeOverlayEl.style.webkitBackdropFilter = `blur(${blur}px)`;
                }
                // Flash: whiteout overlay
                if(flashOverlayEl){
                  flashOverlayEl.style.opacity = String(Math.min(1, flash));
                }
              }
            });

            // Patch 7-4B: shared ammo refill engine (ammo_pack + shop ammo refills)
            ammoRefillService = new AmmoRefillService({
              profile: window.playerProfile,
              weaponSystem,
              onStatus: (text, blink)=>{
                const elS = document.getElementById('ammoStatus');
                if(!elS) return;
                if(text){ elS.textContent = String(text); }
                else{
                  // don't clear if weapon reload/empty is active; HUD update loop will handle it
                }
                if(blink) elS.classList.add('blink');
              }
            });

            // expose for ShopSystem (ammo refill utilities)
            window.ammoRefillService = ammoRefillService;
            try{ window.playerProfile.ammoRefillService = ammoRefillService; }catch{}

            // Patch 7-4B: class item system (Key6/7 use + binocular zoom)
            classItemSystem = new ClassItemSystem({
              profile: window.playerProfile,
              camera,
              scene: current.scene,
	              collisionWorld,
              getCollidables: ()=> collidableMeshes,
              getPlayerObject: ()=> playerObject,
              getEntities: ()=> [{ position: playerObject?.position, hp: window.playerHp, maxHp: window.playerMaxHp, team: window.playerProfile?.team || 'blue' }],
              throwablesSystem,
              ammoRefill: ammoRefillService,
              onSound: (name)=> soundSystem?.play?.(name),
              onHUD: (payload)=>{
                // binocular UI is handled below in the HUD update loop
              }
            });

            // Patch 7-4B: binocular +/- buttons (mobile-friendly)
            if(!window.__strikegyBinoBound){
              window.__strikegyBinoBound = true;
              const m = document.getElementById('binoMinus');
              const p = document.getElementById('binoPlus');
              if(m) m.addEventListener('click', (e)=>{ e.preventDefault(); classItemSystem?.adjustBinoZoom?.(-1); });
              if(p) p.addEventListener('click', (e)=>{ e.preventDefault(); classItemSystem?.adjustBinoZoom?.(+1); });
              // prevent click from also firing
              if(m) m.addEventListener('mousedown', (e)=> e.stopPropagation());
              if(p) p.addEventListener('mousedown', (e)=> e.stopPropagation());
              if(m) m.addEventListener('touchstart', (e)=> e.stopPropagation(), { passive:false });
              if(p) p.addEventListener('touchstart', (e)=> e.stopPropagation(), { passive:false });
            }
    // Patch 5A/6: PC bindings
    // (guard to avoid duplicate binds when reloading maps)
    if(!window.__strikegyBoundInputs){
      window.__strikegyBoundInputs = true;

      const isUIBlockedNow = ()=> (window.__strikegyUILock && (window.__strikegyUILock.inventory || window.__strikegyUILock.shop));

      window.addEventListener('contextmenu', (e)=> e.preventDefault());
      window.addEventListener('mousedown', (e)=>{
        if(isUIBlockedNow()) return;
        if(e.button===0) mouseLeftDown = true;
        if(e.button===2) mouseRightDown = true;
      });
      window.addEventListener('mouseup', (e)=>{
        if(isUIBlockedNow()) return;
        if(e.button===0) mouseLeftDown = false;
        if(e.button===2) mouseRightDown = false;
      });

      window.addEventListener('wheel', (e)=>{
        if(isUIBlockedNow()) return;
        // Patch 7-4B: binocular zoom uses wheel while aiming
        if(classItemSystem && classItemSystem.isBinoAiming?.()){
          const used = classItemSystem.onWheel?.(e);
          if(used){ e.preventDefault(); return; }
        }
        weaponSwitchManager?.cycleNext?.();
        e.preventDefault();
      }, { passive:false });

      window.addEventListener('keydown', (e)=>{
        if(isUIBlockedNow()) return;

        // reload (only when holding a gun)
        if(e.code==='KeyR'){
          const a = window.playerProfile?.activeSlot;
          if(a && (a.type==='primary' || a.type==='secondary')){
            weaponSystem?.startReload?.();
          }
          return;
        }

        // switching (Patch 6-3)
        if(e.code==='Digit1'){ weaponSwitchManager?.switchToPrimary?.(); return; }
        if(e.code==='Digit2'){ weaponSwitchManager?.switchToSecondary?.(); return; }
        if(e.code==='Digit3'){ weaponSwitchManager?.switchToGrenade?.(0); return; }
        if(e.code==='Digit4'){ weaponSwitchManager?.switchToGrenade?.(1); return; }
        if(e.code==='Digit5'){ weaponSwitchManager?.switchToGrenade?.(2); return; }
        if(e.code==='Digit6'){ weaponSwitchManager?.switchToClassItem?.(0); return; }
        if(e.code==='Digit7'){ weaponSwitchManager?.switchToClassItem?.(1); return; }
        if(e.code==='KeyF'){ weaponSwitchManager?.triggerMeleeAttack?.(); return; }
      });
    }
document.getElementById("status").textContent =
          "Î°úÎìú ÏôÑÎ£å. Ï∫îÎ≤ÑÏä§Î•º ÌÅ¥Î¶≠ÌïòÎ©¥(PC) Ìè¨Ïù∏ÌÑ∞ÎùΩÏù¥ Í±∏Î¶¨Í≥† ÏãúÏ†ê ÌöåÏ†ÑÎßå ÌôúÏÑ±ÌôîÎê©ÎãàÎã§. (Patch 4A)";
      } catch (e){
        console.error(e);
        document.getElementById("status").textContent = "Î°úÎìú Ïã§Ìå®";
        showError(path, e);
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      try{ rewardFloat?.update?.(dt); }catch(e){}
      // Patch 9-1: Mode rules tick + objective/capture HUD update (throttled)
      try{
        modeSystem?.update?.(dt, {
          playerPos: playerObject?.position || null,
          playerTeam: (window.playerProfile?.team || "blue"),
          playerAlive: !playerDead,
          bots: botManager?.bots || []
        });

        // Patch 9-3C: economy hooks from mode events (capture tick / capture complete)
        try{
          const evs = modeSystem?.consumeEvents?.() || [];
          for(const ev of evs){
            if(!ev) continue;
            if(ev.type === "ZONE_CAPTURING"){
              const ids = Array.isArray(ev.ids) ? ev.ids : [];
              const n = Math.max(1, ids.length || 1);
              for(const id of ids){
                if(id === "player") economyManager?.rewardZoneCapturing?.(ev.dt, n);
                else {
                  const b = botManager?.bots?.find?.(x=>String(x.id)===String(id));
                  b?.economy?.rewardZoneCapturing?.(ev.dt, n);
                }
              }
            }
            if(ev.type === "ZONE_CAPTURE"){
              const ids = Array.isArray(ev.ids) ? ev.ids : [];
              const n = Math.max(1, ids.length || 1);
              for(const id of ids){
                if(id === "player") economyManager?.rewardZoneCapture?.(n);
                else {
                  const b = botManager?.bots?.find?.(x=>String(x.id)===String(id));
                  b?.economy?.rewardZoneCapture?.(n);
                }
              }
            }
          }
        }catch(e){}
        _modeUiAcc += dt;
        if(_modeUiAcc >= 0.08){
          _modeUiAcc = 0;
          window.combatUI?.setModeState?.(modeSystem?.getUIState?.({ playerPos: playerObject?.position || null }));
        }
      }catch(e){}

      try{
      // Patch 8-0PRO: respawn timer tick
      if(playerDead){
        respawnLeft -= dt;
        window.combatUI?.setRespawning?.(Math.max(0, Math.ceil(respawnLeft)));
        if(respawnLeft <= 0) respawnPlayer();
      }
      // Patch 8-2PRO: Bandage healing tick
      if(!playerDead && bandageHealing){
        const next = playerHP + (bandageHealRate * dt);
        if(next >= playerHPMax){
          setHP(playerHPMax);
          stopBandageHealing();
        }else{
          setHP(next);
        }
      }
      // Patch 8-1PROA: keep world simulation running even when dead
      if(throwablesSystem) throwablesSystem.update(dt);
      if(classItemSystem) classItemSystem.update(dt);
      // Patch 8-3C: bots tick even when player is dead
      try{ botManager?.update?.(dt); }catch{}

      economyManager?.tick?.(dt);
      try{ moneyHUD.textContent = `$${Math.floor(window.playerProfile?.money||0)}`; }catch{}

      // Patch 4: ÏûÖÎ†•/Ïπ¥Î©îÎùº/ÌîåÎ†àÏù¥Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
      settingsStore.refresh();
      const controlPreset = settingsStore.controlPreset;
      updateInvBagVisibility();
      const invOpen = inventoryModal.isOpen();
      if(invOpen) mobileHUD.hide(); else if(controlPreset === 'mobile' || controlPreset === 'mobile_kb') mobileHUD.show(); else mobileHUD.hide();
      const st = inputManager.poll(controlPreset);
      if(cameraController){
        cameraController.applyLookDelta(st.lookDX, st.lookDY, controlPreset !== "pc");
        const dbg = cameraController.getDebug?.();
        if(dbg){
          const yEl = document.getElementById('yawVal');
          const pEl = document.getElementById('pitchVal');
          if(yEl) yEl.textContent = dbg.yawDeg;
          if(pEl) pEl.textContent = dbg.pitchDeg;
        }
      }
      if(playerController && !playerDead){
        // Patch 7-4I: platform-aware groundY.
        // Our PlayerController uses a simple ground plane (groundY). To let players *stand on top*
        // of inner walls after climbing, we dynamically set groundY to the highest nearby wall top.
        const computePlatformGroundY = (pos, halfH) => {
          try{
            const baseGround = 0;
            const cw = collisionWorld;
            if(!cw || !cw.boxes) return baseGround;
            const r = playerController?.radius ?? 0.38;
            const feetY = pos.y - halfH;
            // allow a forgiving "step" window + hysteresis so standing on ledges isn't jittery
            const prev = (typeof playerController.groundY === 'number') ? playerController.groundY : baseGround;
            const EDGE_PAD = 0.18;

            const overlapXZ = (b, pad=0)=>{
              if(pos.x < b.min.x - r - pad || pos.x > b.max.x + r + pad) return false;
              if(pos.z < b.min.z - r - pad || pos.z > b.max.z + r + pad) return false;
              return true;
            };

            // Hysteresis: if we were already standing on a platform, keep it a bit longer near edges
            // to avoid flicker (0 <-> wallTop) while walking.
            let best = baseGround;
            if(prev > 0){
              for(const b of cw.boxes){
                if(!b || b.type !== 'wall') continue;
                const top = b.max.y;
                if(Math.abs(top - prev) > 0.02) continue;
                if(!overlapXZ(b, EDGE_PAD)) continue;
                if(feetY >= top - 0.55 && feetY <= top + 0.95){
                  best = top;
                  break;
                }
              }
            }

            // Switching window: tight-ish below, generous above.
            // (We only switch *up* when feet are already close to the higher platform.)
            const SNAP_BELOW = 0.25;
            const SNAP_ABOVE = 0.65;

            for(const b of cw.boxes){
              if(!b || b.type !== 'wall') continue; // only walls are intended as climb platforms
              if(!overlapXZ(b, 0)) continue;
              const top = b.max.y;
              // feet close enough to treat as ground
              if(feetY >= top - SNAP_BELOW && feetY <= top + SNAP_ABOVE){
                if(top > best) best = top;
              }
            }
            return best;
          }catch{ return 0; }
        };

        // Patch 7-4B+: Sniper ladder auto-climb assist (does not pause world)
        const climb = classItemSystem?.getClimbAssist?.(st, dt) || null;
        if(climb && climb.active){
          // While climbing: optionally lock horizontal movement, and disable floor clamp so we don't get snapped down.
          if(climb.lockXZ){ st.moveX = 0; st.moveZ = 0; }
          // Top-out (stepping onto a ledge): push slightly towards the wall and snap to the ladder top.
          if(climb.topOut){
            playerController.vy = 0;
            playerController.gravity = 18;
            // When top-out snaps us onto a wall top, immediately adopt that platform as ground.
            // This prevents the XZ resolver from shoving us off due to being "inside" a wall AABB.
            const halfH = playerController.isCrouched ? playerController.halfHeightCrouch : playerController.halfHeightStand;
            // Patch 7-4J: place onto *surface* using capsule half-height so feet end up above the top face.
            if(climb.placeOnSurface && typeof climb.surfaceY === 'number'){
              playerObject.position.y = Math.max(playerObject.position.y, climb.surfaceY + halfH + 0.02);
            }else if(typeof climb.snapY === 'number'){
              playerObject.position.y = Math.max(playerObject.position.y, climb.snapY);
            }
            if(typeof climb.setX === 'number') playerObject.position.x = climb.setX;
            if(typeof climb.setZ === 'number') playerObject.position.z = climb.setZ;
            playerController.groundY = computePlatformGroundY(playerObject.position, halfH);
          }else{
            playerController.gravity = 0;
            playerController.vy = 0;
            playerController.groundY = -9999;
            playerObject.position.y += (climb.deltaY || 0);
          }
        }else{
          playerController.gravity = 18;
          const halfH = playerController.isCrouched ? playerController.halfHeightCrouch : playerController.halfHeightStand;
          playerController.groundY = computePlatformGroundY(playerObject.position, halfH);
        }
        // ---------------------------
        // Patch 11-D1: Authoritative multiplayer movement (position via server snapshots)
        // ---------------------------
        const __mpMoveX = st.moveX;
        const __mpMoveZ = st.moveZ;
        const __mpSprint = !!st.sprintHeld;

        // Prevent client-side translation when MP is enabled.
        if (window.__mp && window.__mp.enabled) {
          st.moveX = 0;
          st.moveZ = 0;
        }

        playerController.update(dt, st, camera, collisionWorld);

        if (window.__mp && window.__mp.enabled) {
          // send input at a fixed rate
          window.__mp._sendInputTick?.(dt, { moveX: __mpMoveX, moveZ: __mpMoveZ, sprint: __mpSprint, camera });
          // apply last authoritative snapshot for local + remote players
          // NOTE: multigame uses current.scene (not a global `scene` var). Pass it explicitly.
          window.__mp._applySnapshot?.({ playerObject, scene: current.scene, camera, cameraController });
        }


        // Patch 8-1: minimap tick
        try{
          const dbg = cameraController?.getDebug?.();
          let yawRad = 0;
          // Prefer debug yaw when available
          if (dbg && Number.isFinite(Number(dbg.yawDeg))) {
            yawRad = Number(dbg.yawDeg) * Math.PI / 180;
          } else {
            // Fallback: derive yaw from camera forward direction
            try {
              const dir = new THREE.Vector3();
              camera.getWorldDirection(dir);
              // yaw 0 = facing +Z (adjust if your world uses different forward)
              yawRad = Math.atan2(dir.x, dir.z);
            } catch (e) {
              yawRad = Number(camera?.rotation?.y) || 0;
            }
          }
          // Patch 8-3A: push bot markers into minimap
          window.minimap?.setMarkers?.(botManager?.getMinimapMarkers?.() || []);
          window.minimap?.updatePlayer?.({ x: playerObject.position.x, z: playerObject.position.z, yawRad, team: (playerTeam||'BLUE') });
          window.minimap?.draw?.();
        }catch(e){ /* ignore */ }
      }

      // ÏïÑÏ£º ÎØ∏ÏÑ∏Ìïú Î∂ÑÏúÑÍ∏∞: zone edgeÎßå ÏÇ¥Ïßù ÌéÑÏä§ (Í∞ÄÎèÖÏÑ±)
      if(current?.scene){
        // nothing heavy
      }
    // Patch 5B-2: weapons tick (PC + Mobile HUD)
    if(weaponSystem && !playerDead){
      const preset = settingsStore.controlPreset;
      // Patch 7-3C: casing limit per platform (PC 80 / Mobile 30)
      const casingMax = (preset === 'pc') ? 80 : 30;
      casingSystem?.setLimits?.({ maxCount: casingMax, lifeSeconds: 30 });
      const hudActive = (preset === 'mobile' || preset === 'mobile_kb') && !mobileHUD.el.classList.contains('hidden');
      const hudState = hudActive ? mobileHUD.state : null;
      // Patch 9-4F: bandage button only shows when HP < max
      if(hudActive){
        try{ mobileHUD.setBandageVisible?.(!playerDead && playerHP < playerMaxHP); }catch(e){}
      }

      // Compose triggers: keep PC behavior intact, add mobile held/toggle
      const uiBlocked = (inventoryModal && inventoryModal.isOpen && inventoryModal.isOpen()) || (shopModal && shopModal.isOpen && shopModal.isOpen());
      if(uiBlocked){
        // prevent accidental shots/ADS while interacting with UI
        mouseLeftDown = false;
        mouseRightDown = false;
      }
      const aSlot = window.playerProfile?.activeSlot;
      const holdingGun = !!aSlot && (aSlot.type === 'primary' || aSlot.type === 'secondary');
      const invNow = window.playerProfile?.inventory || null;
      const grenadeActive = !!aSlot && (aSlot.type === 'grenade');
      const grenadeId = grenadeActive ? (invNow?.grenades?.[aSlot.index] || null) : null;
      const classActive = !!aSlot && (aSlot.type === 'classItem');
      const classId = classActive ? (invNow?.classItems?.[aSlot.index] || null) : null;
      const meleeActive = !!weaponSwitchManager?.meleeActive;
      const fireHeld = !uiBlocked && holdingGun && !meleeActive && (!!mouseLeftDown || !!(hudState && hudState.fireHeld));
      const adsOn = !uiBlocked && holdingGun && !meleeActive && (!!mouseRightDown || !!(hudState && hudState.adsOn));

      // Patch 7-4A: grenade hold/release throw (PC + Mobile)
      const grenadeHold = !uiBlocked && grenadeActive && !meleeActive && !!grenadeId && (!!mouseLeftDown || !!(hudState && hudState.fireHeld));
      if(throwablesSystem){
        // If UI opened mid-hold, cancel.
        if(uiBlocked && (prevGrenadeHold || throwablesSystem.holding)){
          throwablesSystem.cancelHold?.();
          prevGrenadeHold = false;
        }else{
          if(grenadeHold && !prevGrenadeHold){
            throwablesSystem.beginHold?.(grenadeId, aSlot.index);
          }
          if(!grenadeHold && prevGrenadeHold){
            const spawned = throwablesSystem.releaseThrow?.(grenadeId, aSlot.index);
            if(spawned && invNow && Array.isArray(invNow.grenades)){
              invNow.grenades[aSlot.index] = null; // consume
              weaponSwitchManager?.cycleNext?.();  // auto leave empty grenade slot
            }
          }
          if(!grenadeActive && (prevGrenadeHold || throwablesSystem.holding)){
            throwablesSystem.cancelHold?.();
          }
          prevGrenadeHold = grenadeHold;
        }
      }

      // Patch 7-4B: class item use (press-to-use, no world pause)
      const classPress = !uiBlocked && classActive && !meleeActive && !!classId && (!!mouseLeftDown || !!(hudState && hudState.fireHeld));
      if(classItemSystem){
        if(classPress && !prevClassUse){
          classItemSystem.use?.(aSlot.index|0);
          // consume the click edge so it doesn't accidentally shoot next frame
          mouseLeftDown = false;
        }
        prevClassUse = !!classPress;
      }

      // Binocular aiming piggybacks on ADS input when classItem=binocular
      if(classItemSystem){
        const binoShouldAim = (!uiBlocked && classActive && (classId === 'binocular') && (!!mouseRightDown || !!(hudState && hudState.adsOn)));
        classItemSystem.setBinocularAiming?.(binoShouldAim);
      }

      weaponSystem.setTriggerHeld(fireHeld);
      weaponSystem.setADS(adsOn);

      // Patch 7-2A: weapon hold/ADS movement multipliers (applied in PlayerController)
      // - Holding gun: 0.95
      // - ADS: 0.85 (default) / 0.75 (LMG)
      let weaponSpeedMul = 1.0;
      if(!uiBlocked && holdingGun && !meleeActive){
        weaponSpeedMul *= 0.95;
        if(adsOn){
          const wid = (weaponSystem?.currentId || weaponSystem?.current?.id || "");
          const isLMG = (typeof wid === 'string' && wid.startsWith('lmg')) || (weaponSystem?.current?.name || '').startsWith('LMG');
          weaponSpeedMul *= isLMG ? 0.75 : 0.85;
        }
      }
      if(playerController) playerController.weaponSpeedMul = weaponSpeedMul;

      // One-shot actions (consume pulses in HUD after handling)
      if(!uiBlocked && holdingGun && hudState && hudState.reloadPressed){
        weaponSystem.startReload?.();
      }
      if(!uiBlocked && hudState && hudState.nextWeaponPressed){
        // Patch 7-3B: mobile next weapon = full cycle (includes grenades, excludes melee)
        weaponSwitchManager?.cycleNext?.();
      }
      if(!uiBlocked && hudState && hudState.meleePressed){
        weaponSwitchManager?.triggerMeleeAttack?.();
      }
      // Patch 9-4F: mobile bandage button
      if(!uiBlocked && hudState && hudState.bandagePressed){
        if(!playerDead && playerHP < playerMaxHP){
          startBandageHealing();
        }
      }
      if(!uiBlocked && hudState && (hudState.reloadPressed || hudState.nextWeaponPressed || hudState.meleePressed || hudState.bandagePressed)){
        mobileHUD.consumePulses?.();
      }
weaponSwitchManager?.update?.(dt);
weaponSystem.update(dt);
      // (moved) throwablesSystem update handled earlier
if(decalManager) decalManager.update(dt);
      if(muzzleFlash) muzzleFlash.update(dt);
      if(casingSystem) casingSystem.update(dt);
      if(casingSystem) casingSystem.update(dt);

      // Patch 7-2B: recoil recovery (frame independent)
      if(cameraController){
        const wid = (weaponSystem?.currentId || weaponSystem?.current?.id || "");
        const p = recoilPresetFor(wid);
        const rs = weaponSystem.isADS ? p.retAds : p.retHip;
        cameraController.updateRecoil(dt, rs);
      }

      // Patch 7-2A + 7-4B: smooth ADS FOV (frame-rate independent) + binocular zoom
      const binoActive = !!(classItemSystem && classItemSystem.isBinoAiming?.());
      const baseFov = (classItemSystem?.bino?.baseFov ?? camera?.fov ?? 75);
      const binoFov = baseFov / (classItemSystem?.bino?.zoom ?? 8);
      const targetFov = binoActive
        ? binoFov
        : (weaponSystem.isADS ? weaponSystem.current.adsFov : weaponSystem.current.hipFov);
      if(camera){
        if(lastFov == null) lastFov = camera.fov;
        const speed = (binoActive || weaponSystem.isADS) ? 18 : 14;
        const t = 1 - Math.exp(-speed * dt);
        lastFov = lastFov + (targetFov - lastFov) * t;
        if(Math.abs(camera.fov - lastFov) > 1e-3){
          camera.fov = lastFov;
          camera.updateProjectionMatrix();
        }
      }

      // Patch 7-2B + 7-4B: scope overlay + binocular overlay + crosshair hide
      const scope = (!binoActive && weaponSystem.isADS) ? (weaponSystem.current.scope || '') : '';
      const scopeActive = !!scope;
      if(scopeOverlayEl){
        scopeOverlayEl.style.display = scopeActive ? 'block' : 'none';
        if(scopeActive) scopeOverlayEl.setAttribute('data-scope', scope);
      }
      if(binoOverlayEl){
        binoOverlayEl.style.display = binoActive ? 'block' : 'none';
      }
      if(crosshairEl){
        crosshairEl.style.display = (scopeActive || binoActive) ? 'none' : 'block';
      }

      // HUD
      const elMag = document.getElementById('ammoMag');
      const elRes = document.getElementById('ammoRes');
      const elW = document.getElementById('ammoWeapon');
      const elS = document.getElementById('ammoStatus');
      const aSlotHud = window.playerProfile?.activeSlot;
      const invHud = window.playerProfile?.inventory || null;
      const grenadeActiveHud = !!aSlotHud && aSlotHud.type === 'grenade';
      const classInfo = classItemSystem?.getHUDInfo?.();
      if(classInfo){
        if(elW) elW.textContent = classInfo.weapon || '';
        if(elMag) elMag.textContent = classInfo.magText ?? '';
        if(elRes) elRes.textContent = classInfo.resText ?? '';
      }else if(grenadeActiveHud){
        const gid = invHud?.grenades?.[aSlotHud.index] || null;
        if(elW) elW.textContent = grenadeHudName(gid);
        if(elMag) elMag.textContent = gid ? '1' : '0';
        if(elRes) elRes.textContent = '';
      }else{
        if(elMag) elMag.textContent = weaponSystem.mag;
        if(elRes) elRes.textContent = weaponSystem.reserve;
        if(elW) elW.textContent = weaponSystem.current.name;
      }
      const elSlot = document.getElementById('ammoSlot');
      if(elSlot) elSlot.textContent = weaponSwitchManager?.getActiveLabel?.() || '';

      if(elS){
        if(classInfo){
          elS.textContent = classInfo.status || '';
          if(classInfo.blink) elS.classList.add('blink'); else elS.classList.remove('blink');
        }else if(grenadeActiveHud){
          const gid = invHud?.grenades?.[aSlotHud.index] || null;
          if(!gid){ elS.textContent = 'EMPTY'; elS.classList.add('blink'); }
          else { elS.textContent = ''; elS.classList.remove('blink'); }
        }else{
          if(weaponSystem.isReloading){ elS.textContent = 'RELOADING'; elS.classList.add('blink'); }
          else if(weaponSystem.mag===0 && weaponSystem.reserve===0){ elS.textContent = 'EMPTY'; elS.classList.add('blink'); }
          else { elS.textContent = ''; elS.classList.remove('blink'); }
        }
      }

      // Patch 7-4B: binocular HUD
      const binoHUD = document.getElementById('binoHUD');
      if(binoHUD){
        const show = !!(classItemSystem && classItemSystem.isBinoAiming?.());
        binoHUD.style.display = show ? 'flex' : 'none';
        if(show){
          const t = document.getElementById('binoText');
          const z = classItemSystem?.bino?.zoom;
          if(t && z) t.textContent = `${z}x`;
        }
      }
    }

            }catch(e){
        console.error("animate error", e);
      }


      // Patch 8-1: minimap tick
      try{
        const mm = window.minimap;
        if(mm){
          const po = (typeof playerObject !== "undefined" && playerObject) ? playerObject : null;
          const px = po ? po.position.x : (playerController?.playerObject?.position?.x ?? 0);
          const pz = po ? po.position.z : (playerController?.playerObject?.position?.z ?? 0);
          const yaw = (camera?.rotation?.y ?? 0);
          const team = String(window.playerProfile?.team || "blue").toUpperCase();
          // Patch 8-3A: bot markers
          mm.setMarkers?.(botManager?.getMinimapMarkers?.() || []);
          mm.updatePlayer?.({ x: px, z: pz, yawRad: yaw, team });
          if(Array.isArray(current?.zones) && current.zones.length){
            mm.updateZoneStates?.(current.zones);
          }
          mm.draw?.();
        }
      }catch(e){ /* ignore minimap */ }

if(current?.scene) renderer.render(current.scene, camera);
    }

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Patch 10: in-game menu
    const gameMenuBtn = document.getElementById('gameMenuBtn');
    const gameMenuOverlay = document.getElementById('gameMenuOverlay');
    const gmResume = document.getElementById('gmResume');
    const gmReload = document.getElementById('gmReload');
    const gmLobby = document.getElementById('gmLobby');

    function openGameMenu(){
      try{ document.exitPointerLock?.(); }catch(e){}
      gameMenuOverlay?.classList.add('open');
      gameMenuOverlay?.setAttribute('aria-hidden','false');
    }
    function closeGameMenu(){
      gameMenuOverlay?.classList.remove('open');
      gameMenuOverlay?.setAttribute('aria-hidden','true');
    }
    gameMenuBtn?.addEventListener('click', openGameMenu);
    gmResume?.addEventListener('click', closeGameMenu);
    gmReload?.addEventListener('click', () => { closeGameMenu(); boot(); });
    gmLobby?.addEventListener('click', () => { window.location.href = 'index.html'; });
    gameMenuOverlay?.addEventListener('click', (e) => {
      if(e.target === gameMenuOverlay) closeGameMenu();
    });
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape'){
        if(gameMenuOverlay?.classList.contains('open')) closeGameMenu();
        else openGameMenu();
      }
    });

    // UI hooks
    document.getElementById("backBtn").addEventListener("click", () => {
      window.location.href = "index.html";
    });
    document.getElementById("reloadBtn").addEventListener("click", () => boot());
    document.getElementById("retryBtn").addEventListener("click", () => boot());
    document.getElementById("toLobbyBtn").addEventListener("click", () => {
      window.location.href = "index.html";
    });

    // Start
    await boot();
    animate();
  

  </script>
  <!-- Patch 7-2B: scope overlay (shown only when ADS + weapon has scope) -->
  <div id="scopeOverlay" data-scope="3x">
    <div class="mask"></div>
    <div class="reticle"></div>
  </div>
  <div id="binoOverlay">
    <div class="mask"></div>
    <div class="reticle"></div>
  </div>
  <div id="smokeOverlay"></div>
  <div id="flashOverlay"></div>
<div id="crosshair" style="position:fixed;left:50%;top:50%;width:16px;height:16px;transform:translate(-50%,-50%);pointer-events:none">
<div style="position:absolute;left:7px;top:0;width:2px;height:16px;background:#fff"></div>
<div style="position:absolute;left:0;top:7px;width:16px;height:2px;background:#fff"></div></div>

  <!-- Patch 9-4D: floating reward texts (BF-style) -->
  <div id="rewardFloat" class="rewardFloat"></div>
<div id="ammoHUD" class="ammoHUD">
    <div class="ammoWeapon" id="ammoWeapon">AR-1</div>
    <div class="ammoSlot" id="ammoSlot"></div>
    <div class="ammoNums"><span id="ammoMag">30</span><span class="ammoSep">‚Äî</span><span id="ammoRes">90</span></div>
    <div class="ammoStatus" id="ammoStatus"></div>
  </div>

  <!-- Patch 7-4B: binocular zoom HUD (only visible while aiming with binocular) -->
  <div id="binoHUD" class="binoHUD" style="display:none">
    <button id="binoMinus" class="binoBtn" tabindex="-1">-</button>
    <div id="binoText" class="binoText">8x</div>
    <button id="binoPlus" class="binoBtn" tabindex="-1">+</button>
  </div>

  </body>
</html>