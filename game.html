<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Strikegy — Game</title>

  <!-- Import map: Three.js examples/jsm modules imported from CDN still use the bare specifier "three".
       This lets the browser resolve it without a bundler, while keeping a single Three.js instance. -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <style>
    :root{
      --bg:#0b0f17; --text:#eaf0ff; --muted:#9fb0d0; --line:rgba(255,255,255,.12);
      --panel:rgba(17,26,43,.82);
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family:system-ui, -apple-system, "Noto Sans KR", Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }
    #hud{
      position:fixed; left:14px; top:14px;
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px 12px;
      min-width: 280px;
      box-shadow:0 16px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      z-index:10;
    }
    #hud h1{font-size:14px; margin:0 0 8px; letter-spacing:.3px}
    .row{display:flex; justify-content:space-between; gap:10px; align-items:center; margin:6px 0}
    .k{color:var(--muted); font-size:12px}
    .v{font-weight:800; font-size:12.5px}
    .btns{display:flex; gap:8px; margin-top:10px}
    button{
      border:1px solid var(--line);
      background:rgba(26,42,68,.9);
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:800;
      font-size:12.5px;
    }
    button:hover{filter:brightness(1.05)}
    #status{margin-top:8px; color:var(--muted); font-size:12px; line-height:1.35}
    #overlayError{
      position:fixed; inset:0; display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.55);
      z-index:30;
      padding:24px;
    }
    #overlayError .card{
      width:min(860px, 100%);
      background:rgba(17,26,43,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:16px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
    }
    #overlayError h2{margin:0 0 8px; font-size:16px}
    #overlayError pre{
      margin:10px 0 0;
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:12px;
      overflow:auto;
      max-height:45vh;
      color:#ffd9d9;
      font-size:12px;
      line-height:1.35;
      white-space:pre-wrap;
      word-break:break-word;
    }

    /* ---- Patch 10: In-game menu (official UI) ---- */
    #gameMenuBtn{
      position:fixed;
      left:14px;
      top:14px;
      z-index:60;
      width:44px;
      height:44px;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(17,26,43,.70);
      backdrop-filter: blur(6px);
      color:var(--text);
      font-weight:900;
      font-size:18px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #gameMenuBtn:hover{filter:brightness(1.06)}
    #gameMenuOverlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.55);
      z-index:70;
      padding:24px;
    }
    #gameMenuOverlay.open{display:flex}
    #gameMenuCard{
      width:min(520px, 100%);
      background:rgba(17,26,43,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:16px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
    }
    #gameMenuCard h2{margin:0 0 10px; font-size:16px}
    #gameMenuCard .menuBtns{display:grid; gap:10px}
    #gameMenuCard .menuBtns button{width:100%; justify-content:center}
    canvas{display:block}

    /* ---- Patch 7-2B: Scope overlay ---- */
    #scopeOverlay{
      position:fixed;
      inset:0;
      display:none;
      pointer-events:none;
      z-index:45;
    }
    #scopeOverlay .mask{
      position:absolute;
      inset:0;
      /* Center circle: transparent, outside: dark */
      background:
        radial-gradient(circle at center,
          rgba(0,0,0,0) 0%,
          rgba(0,0,0,0) 38%,
          rgba(0,0,0,0.75) 40%,
          rgba(0,0,0,0.95) 100%);
    }
    #scopeOverlay .reticle{
      position:absolute;
      left:50%; top:50%;
      width:520px; height:520px;
      transform:translate(-50%,-50%);
      border:2px solid rgba(255,255,255,0.85);
      border-radius:999px;
      box-sizing:border-box;
    }
    #scopeOverlay .reticle:before,
    #scopeOverlay .reticle:after{
      content:"";
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      background:rgba(255,255,255,0.85);
    }
    #scopeOverlay .reticle:before{ width:2px; height:520px; }
    #scopeOverlay .reticle:after{ width:520px; height:2px; }

    /* Mild scope-specific tweaks */
    #scopeOverlay[data-scope="3x"] .reticle{ width:480px; height:480px; }
    #scopeOverlay[data-scope="6x"] .reticle{ width:520px; height:520px; }
    #scopeOverlay[data-scope="8x"] .reticle{ width:560px; height:560px; border-width:2px; }

    /* ---- Patch 7-4B: Binocular overlay (separate from scope) ---- */
    #binoOverlay{position:fixed;inset:0;display:none;pointer-events:none;z-index:45;}
    #binoOverlay .mask{position:absolute;inset:0;background:
      radial-gradient(circle at center,
        rgba(0,0,0,0) 0%,
        rgba(0,0,0,0) 46%,
        rgba(0,0,0,0.55) 49%,
        rgba(0,0,0,0.92) 100%);
    }
    #binoOverlay .reticle{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:560px;height:560px;border:2px solid rgba(255,255,255,0.65);border-radius:999px;box-sizing:border-box;
    }
    #binoOverlay .reticle:after{content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:8px;height:8px;border-radius:999px;background:rgba(255,255,255,0.85);
    }

    /* ---- Patch 7-4A: Smoke / Flash overlays ---- */
    #smokeOverlay, #flashOverlay{
      position: fixed;
      inset: 0;
      display: block;
      pointer-events: none;
      opacity: 0;
      z-index: 46;
    }
    #smokeOverlay{
      background: rgba(160, 175, 200, 0.20);
      backdrop-filter: blur(0px);
      -webkit-backdrop-filter: blur(0px);
      transition: opacity 80ms linear;
    }
    #flashOverlay{
      background: rgba(255,255,255,1);
      transition: opacity 45ms linear;
    }
  
    /* ---- Mobile HUD ---- */
.mobileHUD{
  position: fixed; inset: 0;
  pointer-events: none;
  z-index: 40;
  /* iOS safe area */
  --safeB: env(safe-area-inset-bottom, 0px);
  --safeR: env(safe-area-inset-right, 0px);
  --safeL: env(safe-area-inset-left, 0px);
  --safeT: env(safe-area-inset-top, 0px);

  --uiScale: 1;
  --btnSize: calc(60px * var(--uiScale));
  --btnSizeSm: calc(56px * var(--uiScale));
  --btnSizeJump: calc(64px * var(--uiScale));
  --btnSizeFire: calc(88px * var(--uiScale));
  --ammoPad: calc(110px * var(--uiScale));

  --gap: calc(10px * var(--uiScale));
}
.mobileHUD.hidden{ display:none; }

/* Left move zone */
.mh-joystickArea{
  position:absolute;
  left:0; bottom:0;
  width: 45vw;
  height: 55vh;
  pointer-events: auto;
  touch-action: none;
}
.mh-joyBase{
  position: fixed;
  width: 140px; height: 140px;
  border-radius: 999px;
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.18);
  transform: translate(-50%, -50%);
  display:none;
  pointer-events:none;
  z-index: 41;
}
.mh-joyBase.show{ display:block; }
.mh-joyKnob{
  position:absolute;
  left:50%; top:50%;
  width: 52px; height: 52px;
  border-radius: 999px;
  background: rgba(255,255,255,0.14);
  border: 1px solid rgba(255,255,255,0.22);
  transform: translate(-50%, -50%);
}

/* Combat cluster (right-bottom) */
.mh-combat{
  position:absolute;
  right: calc(18px + var(--safeR) + var(--ammoPad));
  bottom: calc(18px + var(--safeB));
  display:flex;
  flex-direction: column;
  align-items: flex-end;
  gap: var(--gap);
  pointer-events:auto;
  touch-action: none;
  z-index: 41;
}

/* Actions stack (jump/crouch/sprint) slightly above combat */
.mh-actions{
  position:absolute;
  right: calc(18px + var(--safeR));
  bottom: calc(18px + var(--safeB) + var(--ammoPad));
  display:flex;
  flex-direction: column;
  align-items: flex-end;
  gap: var(--gap);
  pointer-events:auto;
  touch-action: none;
  z-index: 41;
}

.mh-btn{
  width: var(--btnSize);
  height: var(--btnSize);
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.22);
  background: rgba(20,20,20,.55);
  color: #fff;
  font-weight: 800;
  font-size: 22px;
  line-height: 1;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:auto;
  user-select:none;
  -webkit-user-select:none;
  -webkit-tap-highlight-color: transparent;
}

/* Patch 9-4F: utility */
.mh-hidden{ display:none !important; }
.mh-btn--small{
  width: var(--btnSizeSm);
  height: var(--btnSizeSm);
  font-size: 20px;
}
.mh-btn--fire{
  width: var(--btnSizeFire);
  height: var(--btnSizeFire);
  font-size: 26px;
  border-color: rgba(255,120,120,0.45);
  background: rgba(50,15,15,.55);
}


.mh-btn--jump{
  width: var(--btnSizeJump);
  height: var(--btnSizeJump);
  font-size: 24px;
}
.mh-btn.on{
  outline: 2px solid rgba(255,255,255,.35);
}
.mh-btn.active{
  outline: 3px solid rgba(120,200,255,.75);
  box-shadow: 0 0 18px rgba(120,200,255,.35);
}
.mh-btn.pulse{
  transform: scale(0.94);
}

.mh-lookHint{
  position:absolute;
  right: calc(18px + var(--safeR) + var(--ammoPad));
  top: calc(10px + var(--safeT));
  color: rgba(255,255,255,.55);
  font-size: 12px;
  pointer-events:none;
  z-index: 41;
}
/* ---- End Mobile HUD ---- */
/* ---- Crosshair ---- */
    .crosshair{
      position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%);
      width: 18px; height: 18px; z-index: 44; pointer-events:none;
    }
    .crosshair::before, .crosshair::after{
      content:""; position:absolute; left:50%; top:50%;
      background: rgba(255,255,255,.92);
      box-shadow: 0 2px 10px rgba(0,0,0,.55);
    }
    .crosshair::before{ width: 2px; height: 18px; transform: translate(-50%,-50%); }
    .crosshair::after{ width: 18px; height: 2px; transform: translate(-50%,-50%); }

    /* Patch 9-4D: Battlefield-like floating reward texts */
    .rewardFloat{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index: 50;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, sans-serif;
      font-weight: 800;
      letter-spacing: 0.2px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.55);
    }
    .rewardFloat__line{
      position:absolute;
      left:0;
      top:0;
      white-space:nowrap;
      opacity:0;
      transform: translate(-50%, 10px) scale(0.98);
      transition: opacity 120ms linear;
      font-size: 15px;
    }
    .rewardFloat__line.show{ opacity:1; }

    /* ---- Ammo HUD (bottom-right, vertical; BF-style) ---- */
    .ammoHUD{
      position: fixed;
      right: 18px;
      bottom: 18px;
      z-index: 44;
      color: rgba(255,255,255,.96);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      text-align: right;
      pointer-events:none;
      user-select:none;
      filter: drop-shadow(0 6px 14px rgba(0,0,0,.45));
    }
    .ammoWeapon{

      font-weight: 800;
      font-size: 12px;
      letter-spacing: .06em;
      opacity: .85;
      margin-bottom: 6px;
    }
    .ammoNums{
      display:flex;
      flex-direction: column;
      align-items: flex-end;
      line-height: 1;
    }
    #ammoMag{ font-size: 40px; font-weight: 900; }
    .ammoSep{ font-size: 10px; opacity:.55; margin: 6px 0; }
    #ammoRes{ font-size: 16px; font-weight: 800; opacity:.85; }
    .ammoStatus{
      margin-top: 6px;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: .08em;
      opacity: .9;
      min-height: 14px;
    }
    .ammoStatus.blink{
      animation: blink 0.6s steps(2,end) infinite;
    }
    @keyframes blink{ 50%{ opacity: .15; } }

    /* ---- Patch 7-4B: Binocular HUD (only while binocular aiming) ---- */
    .binoHUD{
      position: fixed;
      right: 18px;
      bottom: 108px;
      z-index: 45;
      display: flex;
      align-items: center;
      gap: 10px;
      pointer-events: auto;
      user-select:none;
      filter: drop-shadow(0 6px 14px rgba(0,0,0,.45));
    }
    .binoText{
      color: rgba(255,255,255,.95);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 900;
      letter-spacing: .06em;
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      min-width: 54px;
      text-align: center;
    }
    .binoBtn{
      width: 40px;
      height: 40px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.95);
      font-size: 18px;
      font-weight: 900;
      cursor: pointer;
    }
    .binoBtn:active{ transform: scale(0.96); }
    
  
    /* ---- Patch 6-1b: Inventory (Modal) ---- */
    #invBagBtn{
      position:fixed;
      top:10px; right:10px;
      width:46px; height:46px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(17,26,43,.78);
      color:#eaf0ff;
      font-size:22px;
      line-height:1;
      display:none;
      z-index: 55;
      pointer-events:auto;
      backdrop-filter: blur(6px);
      box-shadow:0 10px 24px rgba(0,0,0,.35);
      cursor:pointer;
    }
    #invBagBtn:active{ transform: translateY(1px); }
    @supports (padding: env(safe-area-inset-top)){
      #invBagBtn{
        top: calc(10px + env(safe-area-inset-top));
        right: calc(10px + env(safe-area-inset-right));
      }
    }

    
    /* ---- Patch 6-2b: Shop + Money HUD ---- */
    #moneyHUD{
      position:fixed;
      top:64px; left:14px;
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(17,26,43,.78);
      color:#eaf0ff;
      font-size:14px;
      letter-spacing:.2px;
      z-index: 60;
      pointer-events:none;
      backdrop-filter: blur(6px);
      box-shadow:0 10px 24px rgba(0,0,0,.35);
      display:none;
    }
    #shopCartBtn{
      position:fixed;
      top:10px; right:62px;
      width:46px; height:46px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(17,26,43,.78);
      color:#eaf0ff;
      font-size:22px;
      line-height:1;
      display:none;
      z-index: 60;
      pointer-events:auto;
      backdrop-filter: blur(6px);
      box-shadow:0 10px 24px rgba(0,0,0,.35);
      cursor:pointer;
    }
    #shopCartBtn:active{ transform: translateY(1px); }
    @supports (padding: env(safe-area-inset-top)){
      #moneyHUD{
        top: calc(64px + env(safe-area-inset-top));
        left: calc(14px + env(safe-area-inset-left));
      }
      #shopCartBtn{
        top: calc(10px + env(safe-area-inset-top));
        right: calc(62px + env(safe-area-inset-right));
      }
    }

    .shopOverlay{
      position:fixed; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.55);
      z-index: 90;
      pointer-events:auto;
    }
    .shopModal{
      width:min(620px, calc(100vw - 24px));
      max-height: min(84vh, 760px);
      overflow:auto;
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: 18px;
      box-shadow:0 22px 70px rgba(0,0,0,.55);
      padding: 14px;
    }
    .shopHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .shopTitle{ font-weight:900; font-size:18px; }
    .shopMoney{ font-weight:800; opacity:.95; }
    .shopClose{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:#eaf0ff;
      border-radius: 10px;
      padding:6px 10px;
      cursor:pointer;
    }
    .shopTabs{ display:flex; gap:8px; margin:10px 0 12px; flex-wrap:wrap; }
    .shopTab{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color:#eaf0ff;
      border-radius: 999px;
      padding:8px 10px;
      cursor:pointer;
      font-size:13px;
    }
    .shopTab.active{ background: rgba(105,169,255,.18); border-color: rgba(105,169,255,.35); }
    .shopList{ display:flex; flex-direction:column; gap:8px; }
    .shopSection{ margin-top:4px; font-weight:800; opacity:.9; }
    .shopItem{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:10px;
      background: rgba(255,255,255,.03);
    }
    .shopItemLeft{ display:flex; align-items:center; gap:10px; }
    .shopIcon{ width:36px; height:36px; border-radius:12px; display:flex; align-items:center; justify-content:center;
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10); }
    .shopMid{ display:flex; flex-direction:column; gap:2px; }
    .shopName{ font-weight:800; }
    .shopSub{ font-size:12px; opacity:.85; }
    .shopBuy{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(105,169,255,.16);
      color:#eaf0ff;
      border-radius: 12px;
      padding:8px 12px;
      cursor:pointer;
      font-weight:800;
      white-space:nowrap;
    }
    .shopBuy.disabled{ opacity:.45; cursor:not-allowed; }
    .shopBuy:disabled{ opacity:.45; cursor:not-allowed; }
    .shopHint{ font-size:12px; opacity:.75; margin-top:6px; }
    .shopToast{ margin-top:10px; font-size:13px; opacity:0; transition: opacity .12s ease; }
    

.invOverlay{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.55);
      z-index: 80;
      pointer-events:auto;
    }
    .invModal{
      width:min(540px, calc(100vw - 24px));
      max-height: min(82vh, 720px);
      overflow:auto;
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: 18px;
      box-shadow:0 22px 70px rgba(0,0,0,.55);
      padding: 14px;
    }
    .invHeader{
      display:flex;
      align-items:center;
      gap:10px;
      padding-bottom: 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      margin-bottom: 12px;
    }
    .invTitle{ font-weight:900; letter-spacing:.02em; }
    .invSub{ opacity:.85; margin-left:auto; }
    .invCloseBtn{
      margin-left:8px;
      width:36px; height:36px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.12);
      color:#eaf0ff;
      cursor:pointer;
    }
    .invGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:10px;
    }
    @media (max-width: 520px){
      .invGrid{ grid-template-columns: 1fr; }
    }
    .invSlot{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      gap:4px;
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.10);
      color:#eaf0ff;
      cursor:pointer;
      text-align:left;
      user-select:none;
    }
    .invSlot.is-selected{
      border-color: rgba(31,79,255,.95);
      box-shadow: 0 0 0 2px rgba(31,79,255,.35) inset;
    }
    .invSlot.is-locked{
      opacity:.8;
      background:rgba(0,0,0,.06);
    }
    .invSlotIcon{ font-size:22px; }
    .invSlotLabel{ font-size:12px; opacity:.75; }
    .invSlotName{ font-size:13px; font-weight:800; opacity:.92; }

    .ammoSlot{ margin-top: 2px; font-size: 11px; font-weight: 800; letter-spacing: .08em; opacity: .72; }


  /* Patch 8-1: Minimap (top-right) */
  #minimapWrap{
    position:fixed;
    top:16px;
    right:16px;
    width:220px;
    height:220px;
    z-index:40;
    border-radius:50%;
    overflow:hidden;
    pointer-events:none;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  #minimapCanvas{
    width:100%;
    height:100%;
    display:block;
  }
  @media (max-width: 820px){
    #minimapWrap{ width:160px; height:160px; top:12px; right:12px; }
  }

/* Campaign HF8: hide in-game HUD during campaign cutscenes (Chapter 1 only) */
body[data-camp-cutscene="1"] #minimapWrap,
body[data-camp-cutscene="1"] #crosshair,
body[data-camp-cutscene="1"] #ammoHUD,
body[data-camp-cutscene="1"] #mobileHUD,
body[data-camp-cutscene="1"] #hud-root,
body[data-camp-cutscene="1"] #modeUIRoot,
body[data-camp-cutscene="1"] .shopOverlay,
body[data-camp-cutscene="1"] .invOverlay{
  display:none !important;
}

</style>
</head>
<body>
  <!-- Patch 10: remove dev HUD (official build) -->
  <div id="camHud" style="display:none"></div>

  

  <div id="minimapWrap" aria-label="Minimap">
    <canvas id="minimapCanvas" width="220" height="220"></canvas>
  </div>

  <button id="gameMenuBtn" aria-label="Menu" title="Menu">⚙</button>
  <div id="gameMenuOverlay" aria-hidden="true">
    <div id="gameMenuCard" role="dialog" aria-modal="true" aria-labelledby="gameMenuTitle">
      <h2 id="gameMenuTitle">Menu</h2>
      <div class="menuBtns">
        <button id="gmResume">Resume</button>
        <button id="gmReload">Reload</button>
        <button id="gmLobby">Back to Lobby</button>
      </div>
      <div style="margin-top:10px;color:var(--muted);font-size:12px;line-height:1.5">
        ESC로 닫기 · 모바일은 설정 메뉴 버튼을 눌러주세요.
      </div>
    </div>
  </div>

<div id="hud" role="group" aria-label="Map Loader" style="display:none">
    <h1>Map Loader</h1>
    <div class="row"><span class="k">Selected Mode</span><span class="v" id="modeLabel">-</span></div>
    <div class="row"><span class="k">Map</span><span class="v" id="mapLabel">-</span></div>
    <div class="row"><span class="k">World</span><span class="v" id="worldLabel">-</span></div>
    <div class="row"><span class="k">Zones</span><span class="v" id="zonesLabel">-</span></div>
    <div class="btns">
      <button id="backBtn" title="로비로 돌아가기">Lobby</button>
      <button id="reloadBtn" title="맵 재로드">Reload</button>
    </div>
    <div id="status">3D 씬 로딩 중…</div>
  </div>

  <div id="overlayError" aria-live="polite">
    <div class="card">
      <h2>맵 로드 실패</h2>
      <div class="row"><span class="k">Tried</span><span class="v" id="failPath">-</span></div>
      <div class="btns">
        <button id="retryBtn">Retry</button>
        <button id="toLobbyBtn">Back to Lobby</button>
      </div>
      <pre id="failLog"></pre>
    </div>
  </div>

  <script type="module">
  import MuzzleFlash from "./src/effects/MuzzleFlash.js";
  import CasingSystem from "./src/effects/CasingSystem.js";
  import SoundSystem from "./src/audio/SoundSystem.js";
  import { TTSManager } from "./src/audio/TTSManager.js";
    import { SettingsStore } from "./src/core/SettingsStore.js";
    import { InputManager } from "./src/input/InputManager.js";
    import { CameraController } from "./src/camera/CameraController.js";
    import PlayerController from './src/player/PlayerController.js';
    import CollisionWorld from './src/world/CollisionWorld.js';
    import MobileHUD from './src/ui/MobileHUD.js';
    import { MinimapUI } from "./src/ui/MinimapUI.js";
    import { BotManager } from "./src/bots/BotManager.js";
    import { CombatOverlayUI } from './src/ui/CombatOverlayUI.js';
  import { DamageSystem } from './src/combat/DamageSystem.js';
  import { ModeSystem } from "./src/game/ModeSystem.js";
    import InventoryModal from './src/ui/InventoryModal.js';
    import ShopModal from './src/ui/ShopModal.js';
    import { ShopSystem } from './src/game/ShopSystem.js';
  import { AmmoRefillService } from './src/game/AmmoRefillService.js';
  import { ClassItemSystem } from './src/game/ClassItemSystem.js';
  // Patch 0-F: 멀티플레이 제거 (싱글 전용)
    
  import { EconomyManager } from "./src/game/EconomyManager.js";
  import { LoadoutManager } from "./src/game/LoadoutManager.js";
  import { WeaponSwitchManager } from "./src/game/WeaponSwitchManager.js";
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  // Patch 1-G2: lightweight post-processing (performance-first)
  import { EffectComposer } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
  import { ShaderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js";
  import { FXAAShader } from "https://unpkg.com/three@0.160.0/examples/jsm/shaders/FXAAShader.js";
  import { UnrealBloomPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";

  // Patch 1-G2 HF2: 일부 GPU에서 FXAA 셰이더의 과도한 LOD bias(-100.0)가 경고를 유발함.
  // 브라우저(WebGL)에서는 bias 범위가 [-16, 15.99]로 제한되므로, 안전한 값으로 클램프.
  try {
    if (FXAAShader?.fragmentShader && FXAAShader.fragmentShader.includes('-100.0')) {
      FXAAShader.fragmentShader = FXAAShader.fragmentShader.replace(/-100\.0/g, '-8.0');
    }
  } catch (e) {}
  import WeaponSystem from "./src/weapons/WeaponSystem.js";
  import ThrowablesSystem from "./src/weapons/ThrowablesSystem.js";
  // Patch 2-FP: 1인칭 뷰모델(장갑 손 + 무기) 시스템
  import ViewModelSystem from "./src/fp/ViewModelSystem.js";
  import DecalManager from "./src/effects/DecalManager.js";
  import { CLASS_KEY, normalizeClassId, initInventoryForClass, CLASSES } from "./src/data/classes.js";
  // Patch 3-CAMP+: Campaign runtime (dialogue/cutscenes/objectives/checkpoints)
  import { CampaignRuntime } from "./src/campaign/CampaignRuntime.js";
  import { CampaignDB } from "./src/campaign/CampaignData.js";

  // Patch 1-G: color management (stable PBR + tone mapping)
  THREE.ColorManagement.enabled = true;
    // Patch 6-2a: economy manager instance (declared early to avoid TDZ)
    let economyManager = null;
    let ammoRefillService = null;
    let classItemSystem = null;

    // ---------------------------
    // Patch 3: Mode -> Map 선택(Registry)
    // ---------------------------
    const MODE_KEY = "selectedMode";
    const SETTINGS_KEY = "strikegy_settings";

    const DEFAULT_MAP_BY_MODE = {
      zone: "maps/zone_5_v1.json",
      conquest: "maps/conquest_5_v1.json",
      frontline: "maps/frontline_6_lane_v1.json",
    };

    // ---------------------------
    // Campaign v1 (Patch 3-CAMP): mission registry + difficulty
    // - Campaign uses a separate map namespace: maps/campaign/...
    // - Difficulty scales damage dealt/received (bots & player).
    // ---------------------------
    const CAMPAIGN_KEY = "strikegy_campaign_v1";
    // Single source of truth for missions
    const CAMPAIGN_MISSIONS = CampaignDB?.missions || {};

    function getCampaignSession(){
      try{
        const raw = localStorage.getItem(CAMPAIGN_KEY);
        if(!raw) return null;
        const s = JSON.parse(raw);
        return (s && typeof s === 'object') ? s : null;
      }catch{ return null; }
    }

    function isCampaign(){
      try{
        const url = new URL(window.location.href);
        return url.searchParams.get('campaign') === '1';
      }catch{ return false; }
    }

    function getCampaignDifficulty(){
      const s = getCampaignSession();
      const d = s?.difficulty;
      const pd = Math.max(0.1, Math.min(3, Number(d?.playerDamage ?? 1)));
      const ed = Math.max(0.1, Math.min(3, Number(d?.enemyDamage ?? 1)));
      const id = String(d?.id || 'normal');
      return { id, playerDamage: pd, enemyDamage: ed };
    }

    // Expose for debugging / UI overlay
    window.__campaign = { isCampaign, getCampaignSession, getCampaignDifficulty, CAMPAIGN_MISSIONS };

    function safeGetLocal(key, fallback=null){
      try { return localStorage.getItem(key) ?? fallback; } catch { return fallback; }
    }

    function getSelectedMode(){
      const m = safeGetLocal(MODE_KEY, "zone");
      return (m === "zone" || m === "conquest" || m === "frontline") ? m : "zone";
    }


    // ---------------------------
    // Patch 6-1a: Class selection (from lobby)
    // ---------------------------
    function getSelectedClass(){
      const c = safeGetLocal(CLASS_KEY, "assault");
      return normalizeClassId(c);
    }

    function resolveMapPath(){
      // (확장용) 쿼리로 map=... 지정 가능. 없으면 모드 기본맵.
      const url = new URL(window.location.href);
      const mode = getSelectedMode();
      if(url.searchParams.get('campaign') === '1'){
        // Allow forcing a mission via ?mission=... (useful for dev / next-mission transition)
        const s = getCampaignSession();
        const mid = String(url.searchParams.get('mission') || s?.missionId || 'c1_m1_insertion');
        const entry = CAMPAIGN_MISSIONS[mid] || CAMPAIGN_MISSIONS.c1_m1_insertion;
        return entry.map;
      }

      const map = url.searchParams.get("map");
      if (map && map.startsWith("maps/") && map.endsWith(".json")) return map;
      return DEFAULT_MAP_BY_MODE[mode] || DEFAULT_MAP_BY_MODE.zone;
    }

    // ---------------------------
    // Patch 3: MapLoader (fetch + 최소 검증)
    // ---------------------------
    async function loadMapJson(path){
      const url = `${path}?v=${Date.now()}`; // cache bust (old json 방지)
      const res = await fetch(url, { cache: "no-store" });
      if(!res.ok) throw new Error(`Map fetch failed: ${res.status} ${res.statusText}`);
      const data = await res.json();

      if(!data?.meta?.mode) throw new Error("Invalid map: meta.mode missing");
      if(!Array.isArray(data.spawns)) throw new Error("Invalid map: spawns missing");
      if(!Array.isArray(data.zones)) throw new Error("Invalid map: zones missing");
      if(!Array.isArray(data.objects)) throw new Error("Invalid map: objects missing");
      if(!data?.world?.groundSize || data.world.groundSize.length !== 2) throw new Error("Invalid map: world.groundSize missing");

      return data;
    }

    // ---------------------------
    // Patch 3: SceneBuilder (JSON -> Three)
    // ---------------------------

    // ---------------------------
    // Patch 1-G: Graphics Baseline (Outdoor Day + Indoor)
    // ---------------------------
    const __gfx = {
      maxAniso: 1,
      textures: [],
      envCache: Object.create(null),
    };


    // Non-color textures (bump/roughness/etc.): keep in linear space
    const __NON_COLOR = (typeof THREE.NoColorSpace !== 'undefined')
      ? THREE.NoColorSpace
      : ((typeof THREE.LinearSRGBColorSpace !== 'undefined') ? THREE.LinearSRGBColorSpace : null);

    function __gfxSetMaxAniso(n){
      __gfx.maxAniso = Math.max(1, (n|0) || 1);
      for (const t of __gfx.textures) t.anisotropy = __gfx.maxAniso;
    }

    function _mulberry32(seed){
      return function(){
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function _makeCanvasTexture(drawFn, { size=512, repeat=4, colorSpace=THREE.SRGBColorSpace } = {}){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      drawFn(ctx, size);
      const tex = new THREE.CanvasTexture(c);
      if (colorSpace !== null && typeof colorSpace !== 'undefined') tex.colorSpace = colorSpace;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(repeat, repeat);
      tex.anisotropy = __gfx.maxAniso;
      tex.needsUpdate = true;
      __gfx.textures.push(tex);
      return tex;
    }

    function _drawNoise(ctx, S, count, alpha255, seed){
      const rng = _mulberry32(seed);
      for(let i=0;i<count;i++){
        const x = (rng()*S)|0;
        const y = (rng()*S)|0;
        const v = (80 + rng()*160)|0;
        const a = (alpha255/255) * (0.4 + rng()*0.6);
        ctx.fillStyle = `rgba(${v},${v},${v},${a})`;
        ctx.fillRect(x,y,1,1);
      }
    }

    function _texConcrete(){
      const rng = _mulberry32(1337);
      const map = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle = '#b9bcc1';
        ctx.fillRect(0,0,S,S);
        _drawNoise(ctx,S,26000,30,9001);
        // stains
        for(let i=0;i<220;i++){
          const x=rng()*S, y=rng()*S, r=12+rng()*54;
          const g=ctx.createRadialGradient(x,y,0,x,y,r);
          g.addColorStop(0,'rgba(110,110,110,0.10)');
          g.addColorStop(1,'rgba(110,110,110,0)');
          ctx.fillStyle=g;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        }
        // thin cracks
        ctx.globalAlpha = 0.10;
        ctx.strokeStyle = '#1a1a1a';
        for(let i=0;i<70;i++){
          ctx.beginPath();
          let x=rng()*S, y=rng()*S;
          ctx.moveTo(x,y);
          for(let k=0;k<7;k++){
            x += (rng()*2-1)*26;
            y += (rng()*2-1)*26;
            ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }, { size:512, repeat:6, colorSpace:THREE.SRGBColorSpace });

      const bump = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle = 'rgb(128,128,128)';
        ctx.fillRect(0,0,S,S);
        _drawNoise(ctx,S,24000,70,9002);
      }, { size:512, repeat:6, colorSpace: __NON_COLOR });

      return { map, bump };
    }

    function _texDirt(){
      const rng = _mulberry32(4242);
      const map = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle = '#6b6a66';
        ctx.fillRect(0,0,S,S);
        // colored noise
        for(let i=0;i<42000;i++){
          const x=(rng()*S)|0, y=(rng()*S)|0;
          const r = 85 + (rng()*60)|0;
          const g = 80 + (rng()*55)|0;
          const b = 70 + (rng()*50)|0;
          const a = 0.05 + rng()*0.10;
          ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
          ctx.fillRect(x,y,1,1);
        }
        // darker patches
        for(let i=0;i<180;i++){
          const x=rng()*S, y=rng()*S, r=18+rng()*78;
          const g=ctx.createRadialGradient(x,y,0,x,y,r);
          g.addColorStop(0,'rgba(40,35,30,0.22)');
          g.addColorStop(1,'rgba(40,35,30,0)');
          ctx.fillStyle=g;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        }
      }, { size:512, repeat:10, colorSpace:THREE.SRGBColorSpace });

      const bump = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle = 'rgb(128,128,128)';
        ctx.fillRect(0,0,S,S);
        _drawNoise(ctx,S,36000,95,4243);
      }, { size:512, repeat:10, colorSpace: __NON_COLOR });

      return { map, bump };
    }

    function _texMetal(){
      const rng = _mulberry32(7777);
      const map = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle = '#3b4048';
        ctx.fillRect(0,0,S,S);
        _drawNoise(ctx,S,22000,50,7778);
        // worn scratches
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = '#c6bfb5';
        for(let i=0;i<180;i++){
          const x=rng()*S, y=rng()*S;
          ctx.fillRect(x,y,1+rng()*14, 1+rng()*2);
        }
        ctx.globalAlpha = 1;
      }, { size:512, repeat:8, colorSpace:THREE.SRGBColorSpace });

      const bump = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle = 'rgb(128,128,128)';
        ctx.fillRect(0,0,S,S);
        _drawNoise(ctx,S,26000,85,7779);
      }, { size:512, repeat:8, colorSpace: __NON_COLOR });

      return { map, bump };
    }

    
    function _texSand(){
      const rng = _mulberry32(424242);
      const map = _makeCanvasTexture((ctx,S)=>{
        // warm sand base
        ctx.fillStyle = '#d8c48a';
        ctx.fillRect(0,0,S,S);
        // fine grain
        for(let i=0;i<42000;i++){
          const x=(rng()*S)|0, y=(rng()*S)|0;
          const v = 170 + (rng()*70)|0;
          const a = 0.04 + rng()*0.10;
          ctx.fillStyle = `rgba(${v},${v-8},${v-28},${a})`;
          ctx.fillRect(x,y,1,1);
        }
        // small pebbles
        for(let i=0;i<480;i++){
          const x=rng()*S, y=rng()*S;
          const r=0.8 + rng()*2.6;
          const v=120 + (rng()*60)|0;
          ctx.fillStyle = `rgba(${v},${v},${v},${0.18 + rng()*0.22})`;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        }
      }, { size:512, repeat:8, colorSpace:THREE.SRGBColorSpace });

      const bump = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle = 'rgb(128,128,128)';
        ctx.fillRect(0,0,S,S);
        _drawNoise(ctx,S,42000,55,424243);
      }, { size:512, repeat:8, colorSpace: __NON_COLOR });

      return { map, bump };
    }

    function _texAsphalt(){
      const rng = _mulberry32(515151);
      const map = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle = '#3a3a3c';
        ctx.fillRect(0,0,S,S);
        // aggregate specks
        for(let i=0;i<52000;i++){
          const x=(rng()*S)|0, y=(rng()*S)|0;
          const v = 40 + (rng()*80)|0;
          const a = 0.05 + rng()*0.14;
          ctx.fillStyle = `rgba(${v},${v},${v},${a})`;
          ctx.fillRect(x,y,1,1);
        }
        // faint wear streaks
        for(let i=0;i<120;i++){
          const y=(rng()*S)|0;
          const w = 40 + (rng()*120);
          const a = 0.03 + rng()*0.05;
          ctx.fillStyle = `rgba(255,255,255,${a})`;
          ctx.fillRect((rng()*S)|0, y, w, 2);
        }
        // occasional cracks
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = 'rgba(10,10,10,0.35)';
        for(let i=0;i<14;i++){
          ctx.beginPath();
          let x=rng()*S, y=rng()*S;
          ctx.moveTo(x,y);
          const steps = 6 + (rng()*10)|0;
          for(let j=0;j<steps;j++){
            x += (rng()*2-1)*26;
            y += (rng()*2-1)*26;
            ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
      }, { size:512, repeat:10, colorSpace:THREE.SRGBColorSpace });

      const bump = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle = 'rgb(128,128,128)';
        ctx.fillRect(0,0,S,S);
        _drawNoise(ctx,S,52000,75,515152);
      }, { size:512, repeat:10, colorSpace: __NON_COLOR });

      return { map, bump };
    }

    function _texTiles(){
      const rng = _mulberry32(616161);
      const map = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle='#b8c0c8';
        ctx.fillRect(0,0,S,S);
        const tile = S/8;
        // grout
        ctx.strokeStyle='rgba(60,60,60,0.55)';
        ctx.lineWidth = 3.0;
        for(let i=0;i<=8;i++){
          const p = i*tile;
          ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,S); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(S,p); ctx.stroke();
        }
        // subtle per-tile variation
        for(let gy=0;gy<8;gy++){
          for(let gx=0;gx<8;gx++){
            const v = 170 + (rng()*50)|0;
            ctx.fillStyle = `rgba(${v},${v+4},${v+10},0.20)`;
            ctx.fillRect(gx*tile+2, gy*tile+2, tile-4, tile-4);
          }
        }
        // light scuffs
        for(let i=0;i<1800;i++){
          const x=(rng()*S)|0, y=(rng()*S)|0;
          const a=0.02+rng()*0.06;
          ctx.fillStyle=`rgba(255,255,255,${a})`;
          ctx.fillRect(x,y,1,1);
        }
      }, { size:512, repeat:6, colorSpace:THREE.SRGBColorSpace });

      const bump = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle='rgb(128,128,128)';
        ctx.fillRect(0,0,S,S);
        // grout as height
        const tile = S/8;
        ctx.strokeStyle='rgba(90,90,90,0.9)';
        ctx.lineWidth=4.0;
        for(let i=0;i<=8;i++){
          const p=i*tile;
          ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,S); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(S,p); ctx.stroke();
        }
        _drawNoise(ctx,S,9000,45,616162);
      }, { size:512, repeat:6, colorSpace: __NON_COLOR });

      return { map, bump };
    }

    function _texPlaster(){
      const rng = _mulberry32(717171);
      const map = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle='#d6d6d2';
        ctx.fillRect(0,0,S,S);
        for(let i=0;i<28000;i++){
          const x=(rng()*S)|0, y=(rng()*S)|0;
          const v=200+(rng()*40)|0;
          const a=0.03+rng()*0.08;
          ctx.fillStyle=`rgba(${v},${v},${v-6},${a})`;
          ctx.fillRect(x,y,1,1);
        }
        // faint stains
        for(let i=0;i<60;i++){
          const x=rng()*S, y=rng()*S;
          const r=20+rng()*90;
          const g=ctx.createRadialGradient(x,y,0,x,y,r);
          g.addColorStop(0,'rgba(120,120,110,0.12)');
          g.addColorStop(1,'rgba(120,120,110,0)');
          ctx.fillStyle=g;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        }
      }, { size:512, repeat:8, colorSpace:THREE.SRGBColorSpace });

      const bump = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle='rgb(128,128,128)';
        ctx.fillRect(0,0,S,S);
        _drawNoise(ctx,S,28000,60,717172);
      }, { size:512, repeat:8, colorSpace: __NON_COLOR });

      return { map, bump };
    }

    function _texBrick(){
      const rng = _mulberry32(818181);
      const map = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle='#6f4b3b';
        ctx.fillRect(0,0,S,S);
        const bw = S/10;
        const bh = S/20;
        // bricks
        for(let y=0;y<20;y++){
          const offset = (y%2)*bw*0.5;
          for(let x=0;x<11;x++){
            const px = x*bw - offset;
            const py = y*bh;
            const v = 90 + (rng()*60)|0;
            ctx.fillStyle = `rgb(${v+40},${v+10},${v})`;
            ctx.fillRect(px+1, py+1, bw-2, bh-2);
          }
        }
        // mortar lines
        ctx.strokeStyle='rgba(210,210,210,0.55)';
        ctx.lineWidth=2.2;
        for(let y=0;y<=20;y++){
          const py=y*bh;
          ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(S,py); ctx.stroke();
        }
        for(let x=0;x<=10;x++){
          const px=x*bw;
          ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,S); ctx.stroke();
        }
        // grime
        for(let i=0;i<14000;i++){
          const x=(rng()*S)|0, y=(rng()*S)|0;
          const a=0.02+rng()*0.08;
          ctx.fillStyle=`rgba(0,0,0,${a})`;
          ctx.fillRect(x,y,1,1);
        }
      }, { size:512, repeat:6, colorSpace:THREE.SRGBColorSpace });

      const bump = _makeCanvasTexture((ctx,S)=>{
        ctx.fillStyle='rgb(128,128,128)';
        ctx.fillRect(0,0,S,S);
        // mortar as lower
        const bw=S/10, bh=S/20;
        ctx.strokeStyle='rgba(90,90,90,0.9)';
        ctx.lineWidth=3.0;
        for(let y=0;y<=20;y++){
          const py=y*bh;
          ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(S,py); ctx.stroke();
        }
        for(let x=0;x<=10;x++){
          const px=x*bw;
          ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,S); ctx.stroke();
        }
        _drawNoise(ctx,S,14000,70,818182);
      }, { size:512, repeat:6, colorSpace: __NON_COLOR });

      return { map, bump };
    }
const __TEX = {
      dirt: _texDirt(),
      concrete: _texConcrete(),
      metal: _texMetal(),
      sand: _texSand(),
      asphalt: _texAsphalt(),
      tiles: _texTiles(),
      plaster: _texPlaster(),
      brick: _texBrick(),
    };

    // Patch 1-G3: Macro variation texture (breaks tiling at mid/long range)
    // - very cheap (single low-frequency noise lookup)
    // - applied in shader via onBeforeCompile (world-position based)
    function _texMacro(){
      const rng = _mulberry32(909090);
      const map = _makeCanvasTexture((ctx,S)=>{
        // base
        ctx.fillStyle = '#808080';
        ctx.fillRect(0,0,S,S);
        // big blobs (low frequency)
        for(let i=0;i<90;i++){
          const x=rng()*S, y=rng()*S;
          const r=18+rng()*78;
          const v = 110 + (rng()*70)|0;
          const g=ctx.createRadialGradient(x,y,0,x,y,r);
          g.addColorStop(0, `rgba(${v},${v},${v},0.55)`);
          g.addColorStop(1, 'rgba(128,128,128,0)');
          ctx.fillStyle=g;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        }
        // subtle grain
        for(let i=0;i<12000;i++){
          const x=(rng()*S)|0, y=(rng()*S)|0;
          const v = 120 + (rng()*40)|0;
          const a = 0.06 + rng()*0.08;
          ctx.fillStyle = `rgba(${v},${v},${v},${a})`;
          ctx.fillRect(x,y,1,1);
        }
      }, { size:256, repeat:1, colorSpace: __NON_COLOR });

      map.wrapS = map.wrapT = THREE.RepeatWrapping;
      map.repeat.set(1,1);
      return map;
    }

    const __MACRO_TEX = _texMacro();

    function _applyMacroVariation(mat, opts={}){
      if(!mat || !mat.isMeshStandardMaterial) return mat;
      if(mat.userData.__macroApplied) return mat;
      mat.userData.__macroApplied = true;

      mat.userData.__macro = {
        map: __MACRO_TEX,
        scale: Number(opts.scale ?? 0.008),     // world scale (bigger number = tighter noise)
        strength: Number(opts.strength ?? 0.16) // 0..1 (subtle)
      };

      mat.onBeforeCompile = (shader)=>{
        shader.uniforms.macroMap = { value: mat.userData.__macro.map };
        shader.uniforms.macroScale = { value: mat.userData.__macro.scale };
        shader.uniforms.macroStrength = { value: mat.userData.__macro.strength };

        // Vertex: add world-position varying
        shader.vertexShader = shader.vertexShader
          .replace('#include <common>', `#include <common>
varying vec3 vWorldPos;`)
          .replace('#include <begin_vertex>', `#include <begin_vertex>
vec4 wp = modelMatrix * vec4(position, 1.0);
vWorldPos = wp.xyz;`);

        // Fragment: sample macro noise in XZ world space and modulate albedo
        shader.fragmentShader = shader.fragmentShader
          .replace('#include <common>', `#include <common>
varying vec3 vWorldPos;
uniform sampler2D macroMap;
uniform float macroScale;
uniform float macroStrength;`)
          .replace('#include <map_fragment>', `#include <map_fragment>
// Patch 1-G3: macro variation (break tiling)
vec2 muv = vWorldPos.xz * macroScale;
vec3 m = texture2D(macroMap, muv).rgb;
float mf = (m.r - 0.5) * 2.0;
diffuseColor.rgb *= (1.0 + mf * macroStrength);`);
      };

      mat.needsUpdate = true;
      return mat;
    }

    const MATERIAL_BY_TYPE = {
      ground: new THREE.MeshStandardMaterial({
        color: 0xffffff,
        map: __TEX.dirt.map,
        bumpMap: __TEX.dirt.bump,
        bumpScale: 0.25,
        roughness: 0.98,
        metalness: 0.0,
      }),
      wall: new THREE.MeshStandardMaterial({
        color: 0xffffff,
        map: __TEX.concrete.map,
        bumpMap: __TEX.concrete.bump,
        bumpScale: 0.20,
        roughness: 0.93,
        metalness: 0.0,
      }),
      cover: new THREE.MeshStandardMaterial({
        color: 0xffffff,
        map: __TEX.metal.map,
        bumpMap: __TEX.metal.bump,
        bumpScale: 0.15,
        roughness: 0.72,
        metalness: 0.65,
      }),
    };

    // Patch 3-CAMP HF5: Material sets per map/profile (more variety per campaign map)
    const MATERIAL_SETS = {
      // default outdoor
      outdoor_day: {
        ground: { tex: __TEX.dirt,     bumpScale: 0.25, roughness: 0.98, metalness: 0.0 },
        wall:   { tex: __TEX.concrete, bumpScale: 0.20, roughness: 0.93, metalness: 0.0 },
        cover:  { tex: __TEX.metal,    bumpScale: 0.15, roughness: 0.72, metalness: 0.65 },
      },
      // desert / sand
      desert: {
        ground: { tex: __TEX.sand,     bumpScale: 0.20, roughness: 0.99, metalness: 0.0 },
        wall:   { tex: __TEX.concrete, bumpScale: 0.18, roughness: 0.92, metalness: 0.0 },
        cover:  { tex: __TEX.metal,    bumpScale: 0.14, roughness: 0.70, metalness: 0.60 },
      },
      // urban asphalt
      urban: {
        ground: { tex: __TEX.asphalt,  bumpScale: 0.18, roughness: 0.96, metalness: 0.0 },
        wall:   { tex: __TEX.brick,    bumpScale: 0.16, roughness: 0.92, metalness: 0.0 },
        cover:  { tex: __TEX.metal,    bumpScale: 0.16, roughness: 0.68, metalness: 0.62 },
      },
      // industrial yard
      industrial: {
        ground: { tex: __TEX.concrete, bumpScale: 0.16, roughness: 0.95, metalness: 0.0 },
        wall:   { tex: __TEX.metal,    bumpScale: 0.10, roughness: 0.78, metalness: 0.55 },
        cover:  { tex: __TEX.metal,    bumpScale: 0.16, roughness: 0.70, metalness: 0.65 },
      },
      // indoor facility
      facility: {
        ground: { tex: __TEX.tiles,    bumpScale: 0.10, roughness: 0.90, metalness: 0.0 },
        wall:   { tex: __TEX.plaster,  bumpScale: 0.10, roughness: 0.92, metalness: 0.0 },
        cover:  { tex: __TEX.metal,    bumpScale: 0.14, roughness: 0.70, metalness: 0.62 },
      },
      // trench / mud
      trench: {
        ground: { tex: __TEX.dirt,     bumpScale: 0.30, roughness: 0.995, metalness: 0.0, tint: 0x3b332a },
        wall:   { tex: __TEX.dirt,     bumpScale: 0.26, roughness: 0.995, metalness: 0.0, tint: 0x40372c },
        cover:  { tex: __TEX.metal,    bumpScale: 0.16, roughness: 0.78, metalness: 0.55 },
      },
    };

    function _applyMaterialSet(setId){
      const id = String(setId || 'outdoor_day');
      const s = MATERIAL_SETS[id] || MATERIAL_SETS.outdoor_day;

      for(const key of ['ground','wall','cover']){
        const mat = MATERIAL_BY_TYPE[key];
        const info = s[key];
        if(!mat || !info) continue;

        const tex = info.tex?.map;
        const bump = info.tex?.bump;
        if(tex) mat.map = tex;
        if(bump) mat.bumpMap = bump;

        mat.bumpScale = Number(info.bumpScale ?? mat.bumpScale ?? 0.15);
        mat.roughness = Number(info.roughness ?? mat.roughness ?? 0.9);
        mat.metalness = Number(info.metalness ?? mat.metalness ?? 0.0);

        // optional tint for mood (keep texture detail)
        if(info.tint){
          mat.color.setHex(Number(info.tint) >>> 0);
        }else{
          mat.color.setHex(0xffffff);
        }

        mat.needsUpdate = true;
      }

      // Re-apply macro variation only once per material instance (keeps onBeforeCompile)
      try{
        _applyMacroVariation(MATERIAL_BY_TYPE.ground, { scale: 0.006, strength: 0.20 });
        _applyMacroVariation(MATERIAL_BY_TYPE.wall,   { scale: 0.010, strength: 0.14 });
        _applyMacroVariation(MATERIAL_BY_TYPE.cover,  { scale: 0.012, strength: 0.10 });
      }catch(e){}
    }


    // Patch 1-G3: apply macro variation to core materials (break tiling, cheap realism boost)
    _applyMacroVariation(MATERIAL_BY_TYPE.ground, { scale: 0.006, strength: 0.20 });
    _applyMacroVariation(MATERIAL_BY_TYPE.wall,   { scale: 0.010, strength: 0.14 });
    _applyMacroVariation(MATERIAL_BY_TYPE.cover,  { scale: 0.012, strength: 0.10 });

    // Patch 1-G3: Decals (stains/cracks/scorch/bullets) to add "battlefield grime"
    // - performance-first: small transparent planes, pooled per scene, no shadows, no collision
    function _texDecal(kind){
      const k = String(kind||"stain");
      const rng = _mulberry32((k==='bullet')?9901:(k==='crack')?9902:(k==='scorch')?9903:9900);

      const tex = _makeCanvasTexture((ctx,S)=>{
        ctx.clearRect(0,0,S,S);

        if(k === 'scorch'){
          const x=S*0.5, y=S*0.5;
          const r=S*0.46;
          const g=ctx.createRadialGradient(x,y,0,x,y,r);
          g.addColorStop(0,'rgba(0,0,0,0.60)');
          g.addColorStop(0.5,'rgba(20,12,8,0.25)');
          g.addColorStop(1,'rgba(0,0,0,0)');
          ctx.fillStyle=g;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

          // small soot specks
          for(let i=0;i<2400;i++){
            const px=(rng()*S)|0, py=(rng()*S)|0;
            const a=0.02+rng()*0.10;
            ctx.fillStyle=`rgba(0,0,0,${a})`;
            ctx.fillRect(px,py,1,1);
          }
          return;
        }

        if(k === 'crack'){
          ctx.lineWidth = 1.6;
          ctx.strokeStyle = 'rgba(20,20,20,0.55)';
          for(let i=0;i<22;i++){
            ctx.beginPath();
            let x = rng()*S, y = rng()*S;
            ctx.moveTo(x,y);
            const steps = 7 + (rng()*10)|0;
            for(let j=0;j<steps;j++){
              x += (rng()*2-1)*20;
              y += (rng()*2-1)*20;
              ctx.lineTo(x,y);
            }
            ctx.stroke();
          }
          // faint dust
          for(let i=0;i<9000;i++){
            const px=(rng()*S)|0, py=(rng()*S)|0;
            const v=120+(rng()*50)|0;
            const a=0.02+rng()*0.06;
            ctx.fillStyle=`rgba(${v},${v},${v},${a})`;
            ctx.fillRect(px,py,1,1);
          }
          return;
        }

        if(k === 'bullet'){
          const x=S*0.5, y=S*0.5;
          const r=S*0.12;
          const g=ctx.createRadialGradient(x,y,0,x,y,r);
          g.addColorStop(0,'rgba(0,0,0,0.75)');
          g.addColorStop(0.55,'rgba(30,30,30,0.35)');
          g.addColorStop(1,'rgba(0,0,0,0)');
          ctx.fillStyle=g;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
          // tiny chips
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = '#e5e1d8';
          for(let i=0;i<30;i++){
            const px=x+(rng()*2-1)*r*1.2;
            const py=y+(rng()*2-1)*r*1.2;
            ctx.fillRect(px,py,1+rng()*2,1+rng()*2);
          }
          ctx.globalAlpha = 1;
          return;
        }

        // default: stain/mud
        ctx.fillStyle = 'rgba(0,0,0,0)';
        ctx.fillRect(0,0,S,S);

        // splat blobs
        for(let i=0;i<120;i++){
          const x=rng()*S, y=rng()*S;
          const r=6+rng()*36;
          const rr=40+(rng()*60)|0;
          const gg=30+(rng()*50)|0;
          const bb=20+(rng()*40)|0;
          const a=0.05+rng()*0.16;
          const g=ctx.createRadialGradient(x,y,0,x,y,r);
          g.addColorStop(0,`rgba(${rr},${gg},${bb},${a})`);
          g.addColorStop(1,'rgba(0,0,0,0)');
          ctx.fillStyle=g;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        }
        // fine specks
        for(let i=0;i<14000;i++){
          const px=(rng()*S)|0, py=(rng()*S)|0;
          const a=0.02+rng()*0.07;
          ctx.fillStyle=`rgba(60,45,32,${a})`;
          ctx.fillRect(px,py,1,1);
        }
      }, { size:256, repeat:1, colorSpace:THREE.SRGBColorSpace });

      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.repeat.set(1,1);
      return tex;
    }

    const __DECAL_TEX = {
      stain:  _texDecal('stain'),
      crack:  _texDecal('crack'),
      scorch: _texDecal('scorch'),
      bullet: _texDecal('bullet'),
    };

    const __DECAL_MAT = {
      stain: new THREE.MeshStandardMaterial({
        color: 0xffffff, map: __DECAL_TEX.stain, transparent:true, depthWrite:false,
        roughness: 1.0, metalness: 0.0
      }),
      crack: new THREE.MeshStandardMaterial({
        color: 0xffffff, map: __DECAL_TEX.crack, transparent:true, depthWrite:false,
        roughness: 1.0, metalness: 0.0
      }),
      scorch: new THREE.MeshStandardMaterial({
        color: 0xffffff, map: __DECAL_TEX.scorch, transparent:true, depthWrite:false,
        roughness: 1.0, metalness: 0.0
      }),
      bullet: new THREE.MeshStandardMaterial({
        color: 0xffffff, map: __DECAL_TEX.bullet, transparent:true, depthWrite:false,
        roughness: 1.0, metalness: 0.0
      }),
    };

    for(const k in __DECAL_MAT){
      const m = __DECAL_MAT[k];
      m.polygonOffset = true;
      m.polygonOffsetFactor = -2;
      m.polygonOffsetUnits = -2;
    }

    const __VZ = new THREE.Vector3(0,0,1);
    const __DECAL_GEO = new THREE.PlaneGeometry(1, 1);

    function _spawnDecal(scene, kind, pos, normal, size, rot){
      const mat = __DECAL_MAT[kind] || __DECAL_MAT.stain;
      const mesh = new THREE.Mesh(__DECAL_GEO, mat);
      mesh.scale.set(size[0], size[1], 1);
      mesh.renderOrder = 10;
      mesh.castShadow = false;
      mesh.receiveShadow = false;

      const n = normal.clone().normalize();
      mesh.quaternion.setFromUnitVectors(__VZ, n);
      if(rot) mesh.rotateOnAxis(n, rot);

      mesh.position.copy(pos);
      scene.add(mesh);

      if(!scene.userData.__decals) scene.userData.__decals = [];
      scene.userData.__decals.push(mesh);
      return mesh;
    }

    function _clearDecals(scene){
      const arr = scene.userData.__decals;
      if(!Array.isArray(arr)) return;
      for(const m of arr){
        try{
          scene.remove(m);
        }catch(e){}
      }
      scene.userData.__decals = [];
    }

    function _scatterGroundDecals(scene, gw, gd, preset='outdoor'){
      const rng = _mulberry32(preset === 'indoor' ? 13579 : 97531);
      const up = new THREE.Vector3(0,1,0);
      const count = (preset === 'indoor') ? 28 : 70;

      for(let i=0;i<count;i++){
        const x = (rng()*gw - gw/2);
        const z = (rng()*gd - gd/2);
        const y = 0.02 + rng()*0.02;
        const kindRoll = rng();
        const kind = (kindRoll < 0.60) ? 'stain' : (kindRoll < 0.85) ? 'crack' : 'scorch';
        const s = (kind === 'bullet') ? 0.6 : (kind === 'scorch') ? (2.2 + rng()*6.5) : (1.4 + rng()*5.0);
        const rot = rng()*Math.PI*2;
        _spawnDecal(scene, kind, new THREE.Vector3(x,y,z), up, [s,s], rot);
      }
    }

    function _scatterWallBullets(scene, objects){
      const rng = _mulberry32(24680);
      if(!Array.isArray(objects)) return;

      for(const obj of objects){
        if(obj.shape !== 'box') continue;
        const t = String(obj.type||'').toLowerCase();
        if(t !== 'wall' && t !== 'cover') continue;

        const [sx, sy, sz] = obj.size;
        const [px, py, pz] = obj.pos;

        const thinX = sx < sz;
        const thickness = thinX ? sx : sz;
        const halfT = thickness/2;

        const n = thinX ? new THREE.Vector3((rng()<0.5)?1:-1, 0, 0)
                        : new THREE.Vector3(0, 0, (rng()<0.5)?1:-1);

        const shots = 1 + ((rng()*3)|0);
        for(let i=0;i<shots;i++){
          const y = (py - sy/2) + 1.2 + rng()*(sy-2.4);
          const along = (thinX ? (pz - sz/2 + 1.0 + rng()*(sz-2.0))
                               : (px - sx/2 + 1.0 + rng()*(sx-2.0)));
          const x = thinX ? (px + n.x*(halfT+0.03)) : along;
          const z = thinX ? along : (pz + n.z*(halfT+0.03));
          const rot = rng()*Math.PI*2;
          const s = 0.45 + rng()*0.55;
          _spawnDecal(scene, 'bullet', new THREE.Vector3(x,y,z), n, [s,s], rot);
        }
      }
    }

    function applyDecalsForMap(scene, map){
      _clearDecals(scene);
      const gw = map?.world?.groundSize?.[0] ?? 200;
      const gd = map?.world?.groundSize?.[1] ?? 200;
      const prof = _getProfile(map, 'outdoor_day');
      const preset = (prof?.envKind === 'indoor') ? 'indoor' : 'outdoor';
      _scatterGroundDecals(scene, gw, gd, preset);
      _scatterWallBullets(scene, map?.objects);
    }

    const VISUAL_PROFILES = {
      outdoor_day: {
        id: 'outdoor_day',
        background: 0x87b4e0,
        fog: { color: 0xcfe4ff, near: 220, far: 920 },
        hemi: { sky: 0xd8efff, ground: 0x6f6a5f, intensity: 0.85 },
        sun: { color: 0xffffff, intensity: 3.2, pos: [-90, 150, -40] },
        shadow: { mapSize: 2048, cam: { near: 1, far: 520, left: -220, right: 220, top: 220, bottom: -220 } },
        envKind: 'outdoor',
        exposure: 1.05,
        materialSet: 'outdoor_day',
      },

      desert_noon: {
        id: 'desert_noon',
        background: 0xb7d7ff,
        fog: { color: 0xdaf0ff, near: 260, far: 980 },
        hemi: { sky: 0xe8fbff, ground: 0xa78f63, intensity: 0.92 },
        sun: { color: 0xffffff, intensity: 3.6, pos: [-120, 165, 30] },
        shadow: { mapSize: 2048, cam: { near: 1, far: 560, left: -260, right: 260, top: 260, bottom: -260 } },
        envKind: 'outdoor',
        exposure: 1.08,
        materialSet: 'desert',
      },

      urban_day: {
        id: 'urban_day',
        background: 0x9cc1e8,
        fog: { color: 0xcadcf0, near: 120, far: 640 },
        hemi: { sky: 0xe7f4ff, ground: 0x5f5a52, intensity: 0.70 },
        sun: { color: 0xffffff, intensity: 2.6, pos: [120, 140, -40] },
        shadow: { mapSize: 2048, cam: { near: 1, far: 420, left: -200, right: 200, top: 200, bottom: -200 } },
        envKind: 'outdoor',
        exposure: 1.02,
        materialSet: 'urban',
      },

      industrial_haze: {
        id: 'industrial_haze',
        background: 0x8ea3b4,
        fog: { color: 0xa8b3bd, near: 80, far: 520 },
        hemi: { sky: 0xd9e7f2, ground: 0x3e3f42, intensity: 0.55 },
        sun: { color: 0xffffff, intensity: 2.0, pos: [-40, 120, 90] },
        shadow: { mapSize: 2048, cam: { near: 1, far: 360, left: -180, right: 180, top: 180, bottom: -180 } },
        envKind: 'outdoor',
        exposure: 0.98,
        materialSet: 'industrial',
      },

      trench_overcast: {
        id: 'trench_overcast',
        background: 0x9fb1b8,
        fog: { color: 0xb7c1c6, near: 60, far: 420 },
        hemi: { sky: 0xd9e3e8, ground: 0x2f2a23, intensity: 0.48 },
        sun: { color: 0xffffff, intensity: 1.6, pos: [60, 110, 40] },
        shadow: { mapSize: 2048, cam: { near: 1, far: 340, left: -170, right: 170, top: 170, bottom: -170 } },
        envKind: 'outdoor',
        exposure: 0.96,
        materialSet: 'trench',
      },

      indoor_facility: {
        id: 'indoor_facility',
        background: 0x141a22,
        fog: { color: 0x141a22, near: 30, far: 190 },
        hemi: { sky: 0x9fb6d6, ground: 0x14171c, intensity: 0.12 },
        sun: { color: 0xffffff, intensity: 0.65, pos: [40, 70, 20] },
        shadow: { mapSize: 1024, cam: { near: 1, far: 220, left: -90, right: 90, top: 90, bottom: -90 } },
        envKind: 'indoor',
        exposure: 0.95,
        materialSet: 'facility',
      },

      // Backward-compat id used by earlier patches
      indoor: {
        id: 'indoor',
        background: 0x0f1622,
        fog: { color: 0x0f1622, near: 36, far: 210 },
        hemi: { sky: 0x9fb6d6, ground: 0x14171c, intensity: 0.12 },
        sun: { color: 0xffffff, intensity: 0.55, pos: [40, 70, 20] },
        shadow: { mapSize: 1024, cam: { near: 1, far: 220, left: -90, right: 90, top: 90, bottom: -90 } },
        envKind: 'indoor',
        exposure: 0.95,
        materialSet: 'facility',
      },
    };

    // Patch 1-G2: PostFX (FXAA + subtle bloom). Performance-first.
    let postFX = null;
    // Patch 3-CAMP+: Campaign runtime instance (only when campaign=1)
    let campaignRuntime = null;

    function _getProfile(map, fallback='outdoor_day'){
      const id = String(map?.world?.visualProfile || map?.world?.profile || fallback);
      return VISUAL_PROFILES[id] || VISUAL_PROFILES[fallback];
    }

    function _ensureEnv(renderer, kind){
      const k = String(kind || 'outdoor');
      if(__gfx.envCache[k]) return __gfx.envCache[k];

      const pmrem = new THREE.PMREMGenerator(renderer);
      pmrem.compileEquirectangularShader();

      const s = new THREE.Scene();
      const domeGeo = new THREE.SphereGeometry(50, 32, 16);
      const tex = _makeCanvasTexture((ctx, S)=>{
        const g = ctx.createLinearGradient(0,0,0,S);
        if(k === 'indoor'){
          g.addColorStop(0,'#1b2433');
          g.addColorStop(1,'#0f1622');
        }else{
          g.addColorStop(0,'#9fd3ff');
          g.addColorStop(0.55,'#87b4e0');
          g.addColorStop(1,'#d6e6ff');
        }
        ctx.fillStyle = g;
        ctx.fillRect(0,0,S,S);
      }, { size:512, repeat:1, colorSpace:THREE.SRGBColorSpace });

      // no tiling for dome
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.repeat.set(1,1);

      const domeMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.BackSide });
      const dome = new THREE.Mesh(domeGeo, domeMat);
      s.add(dome);

      // Patch 1-G2 HF2: sigmaRadians가 크면 내부 샘플 수가 최대치를 넘어 경고가 발생할 수 있음.
      // 성능/안정성을 위해 0.04로 낮춰도 IBL 품질은 충분함.
      const envRT = pmrem.fromScene(s, 0.04);
      const env = envRT.texture;

      domeGeo.dispose();
      domeMat.dispose();
      pmrem.dispose();

      __gfx.envCache[k] = env;
      return env;
    }

    function applyVisualProfile(scene, renderer, map){
      const prof = _getProfile(map, 'outdoor_day');
      // Patch 1-G2: sync postFX tuning to profile (bloom params)
      try{ postFX?.applyProfile?.(prof); }catch(e){}

      // Patch 3-CAMP HF5: swap materials per visual profile
      try{ _applyMaterialSet(prof.materialSet || prof.id); }catch(e){}

      // --- renderer baseline (stable outdoor/day by default) ---
      if('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
      // Patch 1-G2 HF2: three r155+에서 useLegacyLights는 deprecated.
      // 설정을 건드리면 경고가 발생하므로 기본 동작(현대 조명) 그대로 둔다.
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = prof.exposure ?? 1.0;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // --- scene baseline ---
      scene.background = new THREE.Color(prof.background);
      scene.fog = new THREE.Fog(prof.fog.color, prof.fog.near, prof.fog.far);
      scene.environment = _ensureEnv(renderer, prof.envKind);

      // --- baseline lights (hemi + sun) ---
      // Keep stable references so we don't stack lights on reload.
      if(!scene.userData.__gfxLights) scene.userData.__gfxLights = {};
      const L = scene.userData.__gfxLights;

      if(!L.hemi){
        L.hemi = new THREE.HemisphereLight(0xffffff, 0x111111, 1);
        scene.add(L.hemi);
      }
      L.hemi.color.setHex(prof.hemi.sky);
      L.hemi.groundColor.setHex(prof.hemi.ground);
      L.hemi.intensity = prof.hemi.intensity;

      if(!L.sun){
        L.sun = new THREE.DirectionalLight(0xffffff, 1);
        L.sun.castShadow = true;
        // slightly soften shadows
        L.sun.shadow.bias = -0.0002;
        L.sun.shadow.normalBias = 0.02;
        scene.add(L.sun);
      }
      L.sun.color.setHex(prof.sun.color);
      L.sun.intensity = prof.sun.intensity;
      L.sun.position.set(prof.sun.pos[0], prof.sun.pos[1], prof.sun.pos[2]);

      // shadow settings
      const sm = prof.shadow?.mapSize ?? 1024;
      L.sun.shadow.mapSize.set(sm, sm);
      const cam = L.sun.shadow.camera;
      cam.near = prof.shadow.cam.near;
      cam.far  = prof.shadow.cam.far;
      cam.left = prof.shadow.cam.left;
      cam.right = prof.shadow.cam.right;
      cam.top = prof.shadow.cam.top;
      cam.bottom = prof.shadow.cam.bottom;
      cam.updateProjectionMatrix();

      // --- optional extra lights (campaign indoor, etc.) ---
      // clear previous extra lights
      if(Array.isArray(scene.userData.__extraPointLights)){
        for(const pl of scene.userData.__extraPointLights) scene.remove(pl);
      }
      scene.userData.__extraPointLights = [];

      const pts = map?.world?.pointLights;
      if(Array.isArray(pts)){
        for(const def of pts){
          const col = new THREE.Color(def.color ?? 0xffffff);
          const pl = new THREE.PointLight(col, def.intensity ?? 25, def.distance ?? 40, def.decay ?? 2);
          const pos = def.pos || [0,5,0];
          pl.position.set(pos[0], pos[1], pos[2]);
          pl.castShadow = !!def.castShadow;
          scene.add(pl);
          scene.userData.__extraPointLights.push(pl);
        }
      }

      scene.userData.__visualProfile = prof.id;
    }

    const ZONE_MAT = new THREE.MeshStandardMaterial({ color: 0x4fa3ff, transparent: true, opacity: 0.22, roughness: 1, metalness: 0 });
    const ZONE_EDGE = new THREE.LineBasicMaterial({ color: 0x4fa3ff, transparent: true, opacity: 0.9 });

    const TEAM_COLOR = {
      blue: 0x4fa3ff,
      red:  0xff5b5b
    };

    
    // ---------------------------
    // Patch 1-G2: Post-processing (Performance-first)
    // - FXAA: cheap anti-aliasing (keeps edges clean)
    // - Subtle Bloom: tiny highlight glow (10% "A" vibe without killing FPS)
    // ---------------------------
    function createPostFX(renderer, camera){
      const KEY = "strikegy_postfx_v1";
      const state = {
        enabled: true,
        fxaa: true,
        bloom: true,
        // subtle defaults (B 90% / A 10%)
        bloomOutdoor: { strength: 0.16, radius: 0.35, threshold: 0.88 },
        bloomIndoor:  { strength: 0.22, radius: 0.40, threshold: 0.78 },
      };

      try{
        const saved = JSON.parse(localStorage.getItem(KEY) || "null");
        if(saved && typeof saved === "object"){
          // shallow merge
          Object.assign(state, saved);
        }
      }catch(e){}

      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(new THREE.Scene(), camera);
      composer.addPass(renderPass);

      const fxaaPass = new ShaderPass(FXAAShader);
      composer.addPass(fxaaPass);

      // Use half-res bloom internally for performance.
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(1,1), 0.16, 0.35, 0.88);
      composer.addPass(bloomPass);

      function _save(){
        try{
          localStorage.setItem(KEY, JSON.stringify({
            enabled: state.enabled,
            fxaa: state.fxaa,
            bloom: state.bloom,
            bloomOutdoor: state.bloomOutdoor,
            bloomIndoor: state.bloomIndoor,
          }));
        }catch(e){}
      }

      function setScene(scene){
        renderPass.scene = scene;
      }

      function applyProfile(prof){
        const kind = String(prof?.envKind || "outdoor");
        const B = (kind === "indoor") ? state.bloomIndoor : state.bloomOutdoor;
        bloomPass.strength = Number(B?.strength ?? 0.16);
        bloomPass.radius = Number(B?.radius ?? 0.35);
        bloomPass.threshold = Number(B?.threshold ?? 0.88);
      }

      function setOptions(opts){
        if(!opts || typeof opts !== "object") return;
        Object.assign(state, opts);
        fxaaPass.enabled = !!state.fxaa;
        bloomPass.enabled = !!state.bloom;
        _save();
      }

      function resize(){
        const w = window.innerWidth;
        const h = window.innerHeight;
        composer.setSize(w, h);

        const pr = renderer.getPixelRatio();
        // FXAA expects inverse resolution in screen space
        if(fxaaPass.material?.uniforms?.resolution?.value){
          fxaaPass.material.uniforms.resolution.value.set(1/(w*pr), 1/(h*pr));
        }
        // Bloom pass setSize (half res for perf)
        if(typeof bloomPass.setSize === "function"){
          bloomPass.setSize(Math.max(1, Math.floor(w/2)), Math.max(1, Math.floor(h/2)));
        }
      }

      function render(){
        if(state.enabled) composer.render();
        else renderer.render(renderPass.scene, camera);
      }

      // expose simple runtime toggle
      window.__postfx = { state, setOptions, applyProfile, resize };
      window.setPostFX = (opts)=>{ setOptions(opts); };

      // init
      fxaaPass.enabled = !!state.fxaa;
      bloomPass.enabled = !!state.bloom;
      resize();

      return { state, composer, renderPass, fxaaPass, bloomPass, setScene, applyProfile, resize, render, setOptions };
    }

function makeGround(w, d){
      const geo = new THREE.PlaneGeometry(w, d);
      const mesh = new THREE.Mesh(geo, MATERIAL_BY_TYPE.ground);
      mesh.rotation.x = -Math.PI / 2;
      mesh.receiveShadow = true;
      return mesh;
    }

    function makeBox(type, size, pos){
      const [sx, sy, sz] = size;
      const geo = new THREE.BoxGeometry(sx, sy, sz);
      const mat = MATERIAL_BY_TYPE[type] || MATERIAL_BY_TYPE.cover;
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(pos[0], pos[1], pos[2]);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    }

    function makeZoneCircle(radius, pos){
      const geo = new THREE.CylinderGeometry(radius, radius, 0.2, 48, 1, true);
      const mesh = new THREE.Mesh(geo, ZONE_MAT);
      mesh.position.set(pos[0], 0.1, pos[2]);
      mesh.receiveShadow = false;
      mesh.castShadow = false;

      // edge
      const points = [];
      const seg = 64;
      for(let i=0;i<=seg;i++){
        const a = (i/seg) * Math.PI * 2;
        points.push(new THREE.Vector3(Math.cos(a)*radius, 0.12, Math.sin(a)*radius));
      }
      const edgeGeo = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(edgeGeo, ZONE_EDGE);
      line.position.set(pos[0], 0, pos[2]);

      const g = new THREE.Group();
      g.add(mesh);
      g.add(line);
      return g;
    }

    function makeSpawnMarker(team, pos){
      const color = TEAM_COLOR[team] ?? 0xffffff;
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.7, metalness: 0.05 });
      const baseGeo = new THREE.CylinderGeometry(2.2, 2.2, 0.25, 24);
      const base = new THREE.Mesh(baseGeo, mat);
      base.position.set(pos[0], 0.13, pos[2]);

      const coneGeo = new THREE.ConeGeometry(1.5, 3.6, 16);
      const cone = new THREE.Mesh(coneGeo, mat);
      cone.position.set(pos[0], 2.2, pos[2]);

      const g = new THREE.Group();
      g.add(base);
      g.add(cone);
      return g;
    }

    function makePlayerDummy(pos){
      // "스폰 가능한 상태" 확인용 더미 캐릭터 (조작 없음)
      const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9, metalness: 0 });
      const geo = new THREE.CapsuleGeometry(0.55, 0.9, 6, 12);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(pos[0], pos[1], pos[2]);
      mesh.castShadow = true;
      return mesh;
    }

    function buildScene(map){
      const scene = new THREE.Scene();
      const collisionWorld = new CollisionWorld();

      // Patch 1-G: apply visual profile (default = outdoor_day)
      applyVisualProfile(scene, renderer, map);


      const [gw, gd] = map.world.groundSize;
      scene.add(makeGround(gw, gd));

      // objects
      for(const obj of map.objects){
        if(obj.shape === "box"){
          scene.add(makeBox(obj.type, obj.size, obj.pos));
          // Collision: default to collidable for any solid box except floor/ground.
          // (Maps may use different type names; safer to opt-out only for floor-like objects.)
          const t = (obj.type || "").toLowerCase();
          const nonSolid = (t === "floor" || t === "ground" || t === "deco" || t === "decor" || t === "sky");
          const collidable = (obj.collision === false) ? false : !nonSolid;

          if (collidable) {
            collisionWorld.addCenteredBox(obj.type, obj.size, obj.pos);
          }
        }
      }

      // Patch 1-G3: decals (grime/bullets) — cheap realism boost
      applyDecalsForMap(scene, map);

      // zones (표시용)
      const zones = [];
      for(const z of map.zones){
        if(z.shape === "circle"){
          const g = makeZoneCircle(z.radius ?? 20, z.pos);
          scene.add(g);
          zones.push({ id: z.id, pos: z.pos, radius: z.radius ?? 20 });
        }
      }

      // spawns (표시용)
      const spawns = {};
      for(const s of map.spawns){
        const team = s.team;
        spawns[team] = s;
        scene.add(makeSpawnMarker(team, s.pos));
      }

      return { scene, zones, spawns, collisionWorld };
    }

    // ---------------------------
    // Renderer / Camera
    // ---------------------------
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    // Patch 1-G: renderer quality defaults
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;
    renderer.physicallyCorrectLights = true;
    // Patch 1-G: texture anisotropy
    __gfxSetMaxAniso(renderer.capabilities.getMaxAnisotropy());

    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.rotation.order = "YXZ";

    // Patch 4 managers
    const settingsStore = new SettingsStore();
    const inputManager = new InputManager({ domElement: renderer.domElement, settingsStore });

    // Patch 1-G2: enable lightweight postFX (FXAA + subtle bloom)
    postFX = createPostFX(renderer, camera);


    

    // Patch 6-1a/b: Build session profile (class + inventory) from lobby selection
    const __savedClass = (()=>{ try{ return localStorage.getItem(CLASS_KEY); }catch(e){ return null; } })();
    const __classId = normalizeClassId(__savedClass || "assault");
    window.playerProfile = {
      classId: __classId,
      className: (CLASSES[__classId] || CLASSES.assault).name,
      inventory: initInventoryForClass(__classId),
      activeSlot: { type:"secondary", index:0 },
      team: "blue",
    };

    // Patch 8-1PRO: default team is blue unless changed in console
    window.setTeam = function(team){
      const t = String(team||"").toLowerCase();
      window.playerProfile.team = (t === "red" || t === "t") ? "red" : "blue";
      console.log("[Strikegy] Team set to:", window.playerProfile.team);
    };

        // Patch 9-4D: Battlefield-like floating reward texts
        class RewardFloat {
          constructor(root){
            this.root = root;
            this.items = [];
            this.pending = new Map();
            this._flushLeft = 0;
          }
          _labelFor(reason){
            const r = String(reason||"");
            if(r === 'kill') return 'KILL';
            if(r === 'zone_capture') return 'CAPTURE';
            if(r === 'zone_tick') return 'CAPTURING';
            if(r === 'damage_head') return 'HIT (HS)';
            if(r === 'damage') return 'HIT';
            return '';
          }
          push({amount, reason}){
            const a = Math.round(Number(amount)||0);
            if(!a) return;
            // ignore passive ticks to keep the feed clean
            if(String(reason||"") === 'passive') return;
            const label = this._labelFor(reason);
            const key = label || String(reason||"reward");
            const cur = this.pending.get(key) || { amount:0, label };
            cur.amount += a;
            this.pending.set(key, cur);
            this._flushLeft = 0.18;
          }
          _flush(){
            if(!this.root) return;
            const now = performance.now();
            for(const v of this.pending.values()){
              const line = document.createElement('div');
              line.className = 'rewardFloat__line';
              const sign = v.amount >= 0 ? '+' : '';
              const label = v.label ? ` ${v.label}` : '';
              line.textContent = `${sign}$${Math.abs(v.amount)}${label}`;
              line.dataset.t0 = String(now);
              this.root.appendChild(line);
              // initial position (stack)
              const idx = this.items.length;
              this.items.push({ el: line, life: 0, y: -6 - idx*18 });
              requestAnimationFrame(()=> line.classList.add('show'));
            }
            this.pending.clear();
          }
          update(dt){
            if(!this.root) return;
            if(this._flushLeft > 0){
              this._flushLeft -= dt;
              if(this._flushLeft <= 0){
                this._flush();
              }
            }
            // animate existing items upward + fade
            for(let i=this.items.length-1;i>=0;i--){
              const it = this.items[i];
              it.life += dt;
              const t = it.life;
              it.y -= 18 * dt;
              const alpha = Math.max(0, Math.min(1, (t < 0.12 ? t/0.12 : (t > 1.05 ? (1.35 - t)/0.30 : 1))));
              if(it.el){
                it.el.style.opacity = String(alpha);
                it.el.style.transform = `translate(-50%, ${it.y}px) scale(${0.98 + Math.min(0.02, t*0.03)})`;
              }
              if(t >= 1.35){
                try{ it.el?.remove?.(); }catch(e){}
                this.items.splice(i,1);
              }
            }
          }
        }

        let rewardFloat = null;
// Patch 6-2a: Economy manager init
    economyManager = new EconomyManager(window.playerProfile);
    economyManager.initOnGameStart();

    // Patch 9-4D: reward floating texts
    rewardFloat = new RewardFloat(document.getElementById('rewardFloat'));
    economyManager.onReward = (ev)=>{ try{ rewardFloat?.push(ev); }catch(e){} };

    window.__strikegyUILock = window.__strikegyUILock || { inventory:false, shop:false };

// Patch 4.3: Mobile HUD (joystick + buttons + swipe look)
    const mobileHUD = new MobileHUD({ root: document.body, input: inputManager, presetGetter: ()=>settingsStore.controlPreset });

    // Patch 8-0X: Combat overlay UI (HP / damage / death / respawn)
    const combatUI = new CombatOverlayUI({ root: document.body });
    window.combatUI = combatUI;
    // Patch 8-2: Damage system registry (for bots/remote players + headshots)
    const damageSystem = new DamageSystem({ combatUI });
    window.damageSystem = damageSystem;


    // Patch 8-1: Minimap UI (player + zones)
    const __modeForMinimap = (typeof getSelectedMode === "function") ? getSelectedMode() : "zone";
// Patch 8-1E: tighten minimap range + per-mode scaling (Frontline zoom-in)
const __minimapCfgByMode = {
  zone:      { range: 45, uiScale: 1.0 },
  conquest:  { range: 52, uiScale: 1.0 },
  frontline: { range: 34, uiScale: 1.15 },
  bomb:      { range: 38, uiScale: 1.0 },
};
const __mmCfg = __minimapCfgByMode[__modeForMinimap] || __minimapCfgByMode.zone;
const minimap = new MinimapUI(document.getElementById("minimapCanvas"), __mmCfg);
    window.minimap = minimap;


    // Patch 8-0PRO: TEMP Health/Death/Respawn (grenade damage test loop)
    let playerHP = 100;
    let playerHPMax = 100;
    let playerDead = false;
    // Patch 9-4F: simple corpse marker (non-blocking, not targetable)
    let deadBodyMesh = null;
    let respawnLeft = 0;
    // Patch 8-2PRO: Bandage (🩹) - all players start with 1 each life; medic unlimited
    let bandageCount = 1;          // for non-medic
    let bandageHealing = false;
    let bandageHealRate = 0;       // HP per second
    let bandageHealStopOnDamage = true;

    // Campaign: auto HP regeneration
    let playerLastDamagedAt = 0;
    const CAMP_REGEN_DELAY = 5.0;  // seconds after last damage
    const CAMP_REGEN_RATE = 18.0;  // HP per second

    function isMedic(){
      return (window.playerProfile?.classId === "medic");
    }
    function getBandageCount(){
      return isMedic() ? Infinity : bandageCount;
    }
    function syncBandageUI(){
      try{
        const rules = window.__campaignRules || {};
        if(rules.noBandage){
          window.combatUI?.setBandageCount?.(0);
          window.combatUI?.setBandageHintActive?.(false);
          return;
        }
        window.combatUI?.setBandageCount?.(getBandageCount());
        const canUse = (!playerDead) && (playerHP < playerHPMax) && (!bandageHealing) && (isMedic() || bandageCount > 0);
        window.combatUI?.setBandageHintActive?.(!!canUse);
      }catch{}
    }
    function stopBandageHealing(){
      if(!bandageHealing) return;
      bandageHealing = false;
      bandageHealRate = 0;
      syncBandageUI();
    }
    function startBandageHealing(){
      const rules = window.__campaignRules || {};
      if(rules.noBandage) return;
      if(playerDead) return;
      try{
        const myTeam = String(window.playerProfile?.team || 'blue').toLowerCase();
        const st = String(sourceTeam || '').toLowerCase();
        if(st && myTeam && st === myTeam) return; // no friendly damage
      }catch{}
      if(playerHP >= playerHPMax) return;
      if(bandageHealing) return;
      if(!isMedic()){
        if(bandageCount <= 0) return;
        bandageCount -= 1;
      }
      bandageHealing = true;
      bandageHealRate = 15 + Math.random()*6; // 15~21 per sec
      syncBandageUI();
    }


    function setHP(cur){
      playerHP = Math.max(0, Math.min(playerHPMax, Number(cur)));
      window.combatUI?.setHP?.(playerHP, playerHPMax);
      syncBandageUI();
    }

    function getDefaultSpawn(){
      const sp = current?.spawns || null;

      // Team defaults to blue unless changed in console via window.setTeam("red")
      const team = (window.playerProfile?.team || "blue");
      const norm = (t)=> {
        const x = String(t||"").toLowerCase();
        if(x === "red" || x === "t") return "red";
        return "blue";
      };
      const key = norm(team);

      // Hotfix 9-4E.2: Conquest defender team spawns behind the current frontline zone.
      // Rule: if frontline zone is B, defender spawns at C; if frontline is last, spawn at last.
      try{
        if(String(mode||'').toLowerCase() === 'conquest'){
          const ms = window.modeSystem;
          const def = String(ms?.conquestDefender || 'red').toLowerCase();
          if(key === def){
            const order = ms?.order;
            if(Array.isArray(order) && order.length){
              const fi = (ms?.conquestFrontIndex ?? 0) | 0;
              const idx = Math.min(fi + 2, order.length - 1);
              const zid = order[idx];
              const zones = (window._map?.zones || current?.map?.zones || current?.zones || []);
              const z = (zones || []).find(zz => String(zz?.id ?? '').toUpperCase() === String(zid).toUpperCase());
              if(z){
                const p = z.pos ?? z.position ?? [0,2,0];
                const x = Number(p[0] ?? p.x ?? 0) || 0;
                const y = Number(p[1] ?? p.y ?? 2) || 2;
                const zc = Number(p[2] ?? p.z ?? 0) || 0;
                return { pos: [x, y, zc], yaw: 0 };
              }
            }
          }
        }
      }catch(e){ /* fall back to spawn table */ }

      // current.spawns is a map: { blue: spawnObj, red: spawnObj, ... }
      const pickOne = (k)=> (sp && sp[k]) ? sp[k] : null;

      // Team spawn first, then sensible fallbacks
      return pickOne(key) || pickOne(key === "blue" ? "red" : "blue")
        || pickOne("ct") || pickOne("t") || pickOne("all") || null;
    }

    function killPlayer(){
      if(playerDead) return;
      playerDead = true;

      const _isCampaign = !!(window.__campaign?.isCampaign?.());
      // Campaign: dying fails mission (no auto respawn)
      if(_isCampaign){
        try{ window.campaignRuntime?.onPlayerDeath?.(); }catch{}
        // keep corpse + ammo reset, but do not start respawn countdown
        respawnLeft = 999999;
      }else{
        respawnLeft = 5.0;
      }

      try{ modeSystem?.onDeath?.(window.playerProfile?.team || 'blue'); }catch{}
      // Patch 9-1: Zone tickets
      try{ modeSystem?.onDeath?.(window.playerProfile?.team || "blue"); }catch(e){}


      stopBandageHealing();

      // Patch 7-4B+: class-item ammo/mag resets immediately on death (per design)
      try{ classItemSystem?.resetOnDeath?.(); }catch{}

      // Patch 8-4A2: reset ALL weapon magazine/reserve states on death.
      // (Per design: death should wipe per-life ammo state, not carry partial mags.)
      try{ weaponSystem?.resetAllAmmoFull?.(); }catch{}

      // UI
      window.combatUI?.setDead?.({ killerText: "KILLED" });
      window.combatUI?.setRespawning?.(Math.ceil(respawnLeft));

      // Patch 9-4F: simple corpse marker (doesn't block LOS)
      try{
        if(deadBodyMesh){
          current.scene?.remove?.(deadBodyMesh);
          deadBodyMesh.geometry?.dispose?.();
          deadBodyMesh.material?.dispose?.();
          deadBodyMesh = null;
        }
        const geo = new THREE.BoxGeometry(0.35, 0.12, 1.15);
        const mat = new THREE.MeshBasicMaterial({ color: 0x111111, transparent: true, opacity: 0.55 });
        deadBodyMesh = new THREE.Mesh(geo, mat);
        deadBodyMesh.name = "corpse_player";
        deadBodyMesh.userData.ignoreLOS = true;
        const p = playerObject?.position;
        if(p){
          deadBodyMesh.position.set(p.x, Math.max(0.06, (p.y ?? 0) + 0.06), p.z);
        }
        deadBodyMesh.rotation.y = (playerController?.yaw ?? 0);
        current.scene?.add?.(deadBodyMesh);
      }catch(e){}

      // minimal input cancel
      mouseLeftDown = false;
      mouseRightDown = false;
    }

    
// Patch 8-1PRO: respawn inventory reset rules
function resetInventoryForRespawn(){
  const p = window.playerProfile;
  if(!p || !p.inventory) return;

  const inv = p.inventory;

  // Keep melee + class items
  const keepMelee = inv.melee;
  const keepClassItems = Array.isArray(inv.classItems) ? inv.classItems.slice() : [null, null];

  // Reset everything else (keep default pistol)
  inv.primary = null;
  inv.secondary = "pistol1";
  inv.grenades = [null, null, null];

  inv.melee = keepMelee;
  inv.classItems = keepClassItems;

  // Reset per-life class-item state that has ammo/mag semantics
  // Bandage/AmmoBag are infinite => nothing to reset for them.
  if(!p.classItemState) p.classItemState = {};
  const s = p.classItemState;
  // ammo pools used by some class items
  if(typeof s.panzerAmmo === "number") s.panzerAmmo = 2;
  if(typeof s.smokeLauncherAmmo === "number") s.smokeLauncherAmmo = 4;
  // give-limits reset per life
  s.medicGiven = {};
  s.supportGiven = {};

  // Force active slot to default pistol
  p.activeSlot = { type:"secondary", index:0 };

  // Let switch manager resync weapon system on next update
  weaponSwitchManager?.ensureActiveSlot?.();
  weaponSwitchManager?.switchToSecondary?.();
}
function respawnPlayer(){
      playerDead = false;

	      // Patch 9-4F: remove corpse marker on respawn
	      try{
	        if(deadBodyMesh){
	          current.scene?.remove?.(deadBodyMesh);
	          deadBodyMesh.geometry?.dispose?.();
	          deadBodyMesh.material?.dispose?.();
	          deadBodyMesh = null;
	        }
	      }catch(e){}

      // Inventory reset at respawn (keep melee + class items; keep default pistol)
      resetInventoryForRespawn();

      // Bandage reset: 1 per life (medic is infinite)
      bandageCount = 1;
      stopBandageHealing();

      setHP(playerHPMax);

      const sp = getDefaultSpawn();
      if(sp) initPlayerFromSpawn(sp);

      window.combatUI?.respawnFlash?.();
      window.combatUI?.setAlive?.();
    }

    // Explosion damage: distance falloff, local player only (temporary)
    function applyExplosionDamageToLocal({ pos, radius, max, min, sourceTeam=null }){
      // Teamkill/self-damage OFF by spec.
      // - Local player: no self-damage from own throwables.
      // - Bots: only enemies take damage.
      const srcTeam = String(sourceTeam || (window.playerProfile?.team || 'blue')).toLowerCase();
      const ds = window.damageSystem;
      if(!pos || !radius || !ds) return;

      // Apply to damageables (bots etc.)
      try{
        for(const ent of ds._byId?.values?.() || []){
          if(!ent || !ent.alive) continue;
          const tTeam = String(ent.team || 'neutral').toLowerCase();
          if(tTeam === srcTeam) continue; // no team damage
          const mpos = ent.mesh?.position;
          if(!mpos) continue;
          const d = mpos.distanceTo(pos);
          if(d > radius) continue;
          const t = 1 - (d / Math.max(0.001, radius)); // 1..0
          const diff = window.__difficulty || { playerDamage: 1, enemyDamage: 1 };
          const dmg = Math.round(((min ?? 0) + ((max ?? 0) - (min ?? 0)) * t) * (Number(diff.playerDamage) || 1));
          if(dmg <= 0) continue;
          const res = ds.applyDamage(ent.id, dmg, { weaponId: "grenade", sourceTeam: srcTeam, headshot: false });
          try{ economyManager?.rewardDamage?.(dmg, false); }catch{}
          if(res?.killed){
            try{ economyManager?.rewardKill?.(); }catch{}
            try{ modeSystem?.onDeath?.(ent.team); }catch{}
          }
        }
      }catch(e){ console.warn(e); }
    }

    
    // Patch 8-2: Bullet damage for local player (bots will call this later)
    function applyBulletDamageToLocal({ amount, headshot=false, weaponId=null, sourceTeam=null, sourceId=null } = {}){
      // HF9-B2: 컷신 중에는 월드가 정지 (피격/사망 방지)
      try{ if(document?.body?.dataset?.campCutscene === '1') return; }catch(e){}
      if(playerDead) return;
      const base = Math.max(0, Number(amount) || 0);
      const diff = window.__difficulty || { playerDamage: 1, enemyDamage: 1 };
      const dmg = Math.round(base * (Number(diff.enemyDamage) || 1));
      const ratio = Math.min(1, Math.max(0, dmg / playerHPMax));
      window.combatUI?.flashDamage?.(ratio);
      stopBandageHealing();
      playerLastDamagedAt = (performance.now() || 0) / 1000;
      setHP(playerHP - dmg);
      // Economy for bots: bot gains money for damage dealt (and kill if applicable)
      try{
        if(sourceId && botManager?.bots){
          const b = botManager.bots.find(x=>String(x.id)===String(sourceId));
          b?.economy?.rewardDamage?.(dmg, !!headshot);
        }
      }catch(e){}

      if(playerHP <= 0){
        try{
          if(sourceId && botManager?.bots){
            const b = botManager.bots.find(x=>String(x.id)===String(sourceId));
            b?.economy?.rewardKill?.();
          }
        }catch(e){}
        killPlayer();
      }
    }
    window.applyBulletDamageToLocal = applyBulletDamageToLocal;

// initial sync
    setHP(playerHP);
    syncBandageUI();


    
    // Patch 6-1b: Inventory modal + 🎒 button
    const inventoryModal = new InventoryModal({
      root: document.body,
      input: inputManager,
      settingsStore,
      mobileHUD,
      getProfile: ()=>window.playerProfile
    });

    // Patch 6-2b: Shop system + modal
    const shopSystem = new ShopSystem({ getProfile: ()=>window.playerProfile, getEconomy: ()=>economyManager });
    // --- Shop cart button (mobile UI). Always define to avoid ReferenceError.

    const shopCartBtn = document.getElementById("shopCartBtn") || (() => {

      const b = document.createElement("button");

      b.id = "shopCartBtn";

      b.type = "button";

      b.textContent = "🛒";

      b.setAttribute("aria-label", "상점");

      document.body.appendChild(b);

      return b;

    })();


    
    // --- Money HUD (always define)
    const moneyHUD = document.getElementById("moneyHUD") || (() => {
      const d = document.createElement("div");
      d.id = "moneyHUD";
      d.textContent = "$0";
      document.body.appendChild(d);
      return d;
    })();
    window.moneyHUD = moneyHUD;
const shopModal = new ShopModal({
      root: document.body,
      input: inputManager,
      settingsStore,
      mobileHUD,
      getProfile: ()=>window.playerProfile,
      shopSystem
    });
    // expose for debugging
    window.shopModal = shopModal;

    shopCartBtn.addEventListener('click', (e)=>{ e.preventDefault(); shopModal.toggle(); });


    const invBagBtn = document.createElement("button");
    invBagBtn.id = "invBagBtn";
    invBagBtn.type = "button";
    invBagBtn.textContent = "🎒";
    invBagBtn.title = "Inventory (I)";
    invBagBtn.addEventListener("click", (e)=>{
      e.preventDefault();
      inventoryModal.toggle();
    });
    document.body.appendChild(invBagBtn);

    function updateInvBagVisibility(){
      const p = settingsStore.controlPreset;
      const show = (p === "mobile" || p === "mobile_kb");
      const camp = !!(window.__campaign?.isCampaign?.());
      const rules = window.__campaignRules || {};
      invBagBtn.style.display = (show && !camp) ? "block" : "none";
      shopCartBtn.style.display = (show && !camp && !rules.noShop) ? "block" : "none";
      moneyHUD.style.display = (camp ? "none" : "block");
    }

    // Key bindings (PC + mobile_kb)
    window.addEventListener("keydown", (e)=>{
      const _camp = !!(window.__campaign?.isCampaign?.());
      const _rules = window.__campaignRules || {};
      if(e.code === "KeyB"){
        if(_camp || _rules.noShop) return;
        if(e.repeat) return;
        const tag = document.activeElement?.tagName;
        if(tag === "INPUT" || tag === "TEXTAREA") return;
        try{ shopModal.toggle(); }catch{}
        e.preventDefault();
      }else if(e.code === "KeyI"){
        if(_camp) return;
        if(e.repeat) return;
        const tag = document.activeElement?.tagName;
        if(tag === "INPUT" || tag === "TEXTAREA") return;
        inventoryModal.toggle();
        e.preventDefault();
      }else if(e.code === "KeyC"){
        if(_camp || _rules.noBandage) return;
        if(e.repeat) return;
        const tag = document.activeElement?.tagName;
        if(tag === "INPUT" || tag === "TEXTAREA") return;
        // Use bandage if HP < 100
        startBandageHealing();
        e.preventDefault();
      }else if(e.code === "Escape"){
        if(inventoryModal.isOpen()){
          inventoryModal.close();
          e.preventDefault();
        }
      }
    });

// Patch 4: PC 프리셋이면 캔버스 클릭으로 포인터락
    renderer.domElement.addEventListener("click", () => {
      settingsStore.refresh();
      if(settingsStore.controlPreset !== "pc") return;
      if(document.pointerLockElement !== renderer.domElement){
        renderer.domElement.requestPointerLock?.();
      }
    });

    let cameraController = null;
    let playerController = null;
    let collisionWorld = null;
    let playerObject = null;
    const clock = new THREE.Clock();


    let current = { scene: null, zones: [], spawns: {} };
  // Patch 5A (PC): weapons + decals
  let weaponSystem = null;
  let soundSystem = null;
  let weaponSwitchManager = null;
  // Patch 2-FP: 1인칭 뷰모델
  let viewModelSystem = null;
  let muzzleFlash = null;
  let casingSystem = null;
  let decalManager = null;
  let collidableMeshes = [];
  let mouseLeftDown = false;
  let mouseRightDown = false;
  let lastFov = null;
    // Patch 7-2B: scope overlay DOM cache
    let scopeOverlayEl = null;
    let binoOverlayEl = null;
    let crosshairEl = null;

        let smokeOverlayEl = null;
    let flashOverlayEl = null;

    // Patch 7-4A: Throwables system
    let throwablesSystem = null;
    let prevGrenadeHold = false;
    let prevClassUse = false;

    // Patch 8-3A: Bot manager (movement + minimap markers)
    let botManager = null;

    // Patch 9-1: Mode rules + capture system
    let modeSystem = null;
    let _modeUiAcc = 0;
let _roundShown = false;

    // Patch 7-2B: recoil presets (radians)
    const deg = (d)=> (d * Math.PI / 180);
    function recoilPresetFor(id){
      const s = String(id||"").toLowerCase();
      if(s.startsWith('sr'))  return { pitch: deg(1.35), yaw: deg(0.18), retHip: 10, retAds: 14 };
      if(s.startsWith('dmr')) return { pitch: deg(0.85), yaw: deg(0.18), retHip: 12, retAds: 16 };
      if(s.startsWith('sg'))  return { pitch: deg(1.10), yaw: deg(0.35), retHip: 11, retAds: 14 };
      if(s.startsWith('lmg')) return { pitch: deg(0.65), yaw: deg(0.35), retHip: 11, retAds: 15 };
      if(s.startsWith('smg')) return { pitch: deg(0.35), yaw: deg(0.28), retHip: 14, retAds: 18 };
      if(s.startsWith('ar'))  return { pitch: deg(0.45), yaw: deg(0.22), retHip: 13, retAds: 17 };
      if(s.startsWith('mp'))  return { pitch: deg(0.40), yaw: deg(0.30), retHip: 14, retAds: 18 };
      // pistols
      return { pitch: deg(0.55), yaw: deg(0.20), retHip: 13, retAds: 17 };
    }

    // Patch 7-4A: grenade HUD names
    const GRENADE_LABEL = {
      frag:  "💥 고폭 수류탄",
      smoke: "☁️ 연막탄",
      flash: "✨ 섬광탄",
      impact:"💣 충격 수류탄",
    };
    function grenadeHudName(id){
      const k = String(id||"");
      return GRENADE_LABEL[k] || "투척무기";
    }
    
    function initPlayerFromSpawn(spawn){
      const p = spawn?.pos ?? [0,2,0];
      const yaw = spawn?.yaw ?? 0;

      // 기존 플레이어 제거
      if(playerObject && playerObject.parent) playerObject.parent.remove(playerObject);
      if(camera.parent) camera.parent.remove(camera);

      // 새 플레이어 생성 + 카메라 부착
      playerObject = makePlayerDummy(p);
      current.scene.add(playerObject);
      playerObject.add(camera);
      camera.position.set(0, 1.6, 0);

      // 컨트롤러 생성/갱신
      settingsStore.refresh();
      cameraController = new CameraController({ playerObject, camera, settingsStore });
      cameraController.setFromSpawnYawDegrees(-90); // Patch 4A: 고정 초기 yaw


      playerController = new PlayerController({ playerObject });
      playerController.teleportTo(p);
    }

    function showError(path, err){
      const overlay = document.getElementById("overlayError");
      document.getElementById("failPath").textContent = path;
      document.getElementById("failLog").textContent = String(err?.stack || err?.message || err);
      overlay.style.display = "flex";
    }

    function hideError(){
      document.getElementById("overlayError").style.display = "none";
    }

    async function boot(){
      let mode = getSelectedMode();
      const campaignOn = isCampaign();
      const camp = campaignOn ? getCampaignSession() : null;
      const diff = campaignOn ? getCampaignDifficulty() : { id:'normal', playerDamage:1, enemyDamage:1 };
      // Campaign: override mode label (rules are mission-scripted; no Zone/Conquest/Frontline logic)
      if(campaignOn) mode = 'campaign';

      const path = resolveMapPath();

      document.getElementById("modeLabel").textContent = campaignOn ? `campaign (${diff.id})` : mode;
      if(campaignOn){
        const url = new URL(window.location.href);
        const missionParam = String(url.searchParams.get('mission') || '').trim();
        const replayMode = (url.searchParams.get('replay') === '1');
        const continueParam = (url.searchParams.get('continue') === '1');

        // Active mission for this run (mission param > session > default)
        const activeMid = missionParam || String(camp?.missionId || '') || 'c1_m1_insertion';
        window.__campaignLaunch = {
          missionId: missionParam || null,
          replayMode: !!replayMode,
          continueFromSave: (!!continueParam && !replayMode),
          activeMissionId: activeMid,
        };

        const entry = CAMPAIGN_MISSIONS[activeMid] || CAMPAIGN_MISSIONS.c1_m1_insertion;
        document.getElementById("mapLabel").textContent = entry?.title ? `${entry.title} · ${entry.map}` : path;

        // Apply per-mission campaign rules & fixed loadout (no shop / no class / no bandage)
        try{
          const rules = entry?.rules || { noShop:true, noClass:true, noBandage:true, autoRegen:true };
          window.__campaignRules = rules;
          // Force a neutral "campaign" class state (prevents class-items logic from leaking in)
          window.playerProfile.classId = 'campaign';
          window.playerProfile.className = 'CAMPAIGN';

          const lo = entry?.loadout || { primary:'ar1', secondary:'pistol1', grenades:['frag','flash','smoke'] };
          const inv = window.playerProfile.inventory;
          // Keep slot structure, just rewrite content.
          if(inv){
            inv.primary = [lo.primary || 'ar1'];
            inv.secondary = [lo.secondary || 'pistol1'];
            inv.grenades = Array.isArray(lo.grenades) ? lo.grenades.slice(0,3) : ['frag','flash','smoke'];
            inv.special = [];
            inv.tools = [];
          }
          window.playerProfile.activeSlot = { type:'primary', index:0 };
        }catch(e){ console.warn('[Campaign] apply rules/loadout failed', e); }
      }else{
        document.getElementById("mapLabel").textContent = path;
        window.__campaignRules = null;
      }

      // Expose for damage scaling
      window.__difficulty = diff;

      try{
        hideError();
        document.getElementById("status").textContent = "맵 JSON 로드 중…";

        const map = await loadMapJson(path);
        // Hotfix 9-4E.2: expose map for systems that need it outside boot() scope.
        window._map = map;

        // 표시 업데이트
        const [gw, gd] = map.world.groundSize;
        document.getElementById("worldLabel").textContent = `${gw} x ${gd}`;
        document.getElementById("zonesLabel").textContent = `${map.zones.length}`;

        document.getElementById("status").textContent = "씬 빌드 중…";
        current = buildScene(map);
        collisionWorld = current.collisionWorld;

        // Patch 8-1: minimap bounds + zones (neutral for now)
        try{
          window.minimap?.setBoundsFromGroundSize?.(map.world?.groundSize);
          window.minimap?.setZones?.(map.zones);
          // Patch 8-1C: draw inner/outer walls on minimap (type: "wall")
          window.minimap?.setWalls?.(map.objects);
        }catch(e){ /* ignore minimap failures */ }

        // Patch 9-1: Mode rules init (Zone / Conquest / Frontline)
        // Campaign에서는 미션 스크립트가 룰을 제어하므로 ModeSystem을 비활성화.
        if(mode !== 'campaign'){
          try{
            modeSystem = new ModeSystem({ mode, zones: map.zones, opts: { ticketsBlue:200, ticketsRed:200, conquestTimeLimit: 15*60, frontlineSwapSec: 5*60, frontlineTimeLimit: 15*60 } });
            window.modeSystem = modeSystem;
            // initial HUD render
            window.combatUI?.setModeState?.(modeSystem.getUIState({ playerPos: playerObject?.position || null }));
            if(!_roundShown && modeSystem?.roundEnded){
              _roundShown = true;
              window.combatUI?.showRoundResult?.(modeSystem?.getRoundResult?.());
            }
          }catch(e){ console.warn("ModeSystem init failed:", e); }
        }else{
          modeSystem = null;
          window.modeSystem = null;
        }



        // Patch 4: 플레이어/카메라 초기화 (BLUE 스폰, 없으면 첫 스폰)
        const blue = current.spawns.blue ?? map.spawns[0];
        initPlayerFromSpawn(blue);

        // Patch 3-CAMP+: Campaign runtime (dialogue/cutscenes/objectives/checkpoints)
        if(campaignOn){
          try{
            campaignRuntime = new CampaignRuntime({
              THREE,
              camera,
              inputManager,
              playerController,
              getPlayerObject: ()=> playerObject,
              getPlayerTeam: ()=> (window.playerProfile?.team || 'blue'),
              getSceneRoot: ()=> (current?.scene || null),
              lockPointer: (enabled)=>{
                // For cutscenes we exit pointer lock. We don't force re-lock.
                if(!enabled){
                  try{ document.exitPointerLock?.(); }catch{}
                }
              }
            });
            // Best-effort hook: count kills for mission objectives.
            try{
              const ds = window.damageSystem;
              if(ds && !ds.__campWrapped){
                const _orig = ds.applyDamage.bind(ds);
                ds.applyDamage = (id, amount, meta={})=>{
                  const res = _orig(id, amount, meta);
                  try{ if(res?.killed) campaignRuntime?.onKill?.({ team: res?.ent?.team || null }); }catch{}
                  return res;
                };
                ds.__campWrapped = true;
              }
            }catch{}

            const launch = window.__campaignLaunch || {};
            campaignRuntime.start({
              mapJson: map,
              continueFromSave: !!launch.continueFromSave,
              missionId: launch.missionId || null,
              replayMode: !!launch.replayMode,
            });
            window.campaignRuntime = campaignRuntime;
          }catch(e){ console.warn('[Campaign] init failed', e); }
        }else{
          campaignRuntime = null;
          window.campaignRuntime = null;
        }

        // Patch 8-3A: Bots (spawn at team spawns, roam between zones)
        try{
          if(botManager){
            botManager.clear?.();
          }
          const _botAim = new THREE.Vector3();
          const _launch = window.__campaignLaunch || {};
          const _mid = String(_launch.activeMissionId || camp?.missionId || '') || 'c1_m1_insertion';
          const campEntry = campaignOn ? (CAMPAIGN_MISSIONS[_mid] || CAMPAIGN_MISSIONS.c1_m1_insertion) : null;
          botManager = new BotManager({
            scene: current.scene,
            collisionWorld: collisionWorld,
            map,
            mode,
            difficultyId: settingsStore.botDifficulty,
            playerBaseSpeed: (playerController?.baseSpeed ?? 6),
            // Default bot counts (PvE: campaign may override per-mission)
            botCountBlue: campaignOn ? (campEntry?.bots?.blue ?? 0) : 4,
            botCountRed: campaignOn ? (campEntry?.bots?.red ?? 6) : 5,
            getPlayerPosition: ()=> playerObject?.position || null,
            getPlayerTeam: ()=> (window.playerProfile?.team || 'blue'),
            damageSystem: window.damageSystem,
            getPlayerAimPosition: ()=>{
              const p = playerObject?.position;
              if(!p) return null;
              // Patch 9-4F: dead players are not targetable (prevents bots shooting corpse)
              if(playerDead || playerHP <= 0) return null;
              // aim for upper torso/head area
              return _botAim.set(p.x, (p.y ?? 0) + 1.45, p.z);
            },
            getCollidables: ()=> collidableMeshes,
            onShootPlayer: ({ amount, headshot=false, weaponId=null, sourceTeam=null, sourceId=null }={})=>{
              if(playerDead) return;
              try{ window.applyBulletDamageToLocal?.({ amount, headshot, weaponId, sourceTeam, sourceId }); }catch{}
            },
          });
          // Campaign: allow mission maps to define additional enemy spawn points
          if(campaignOn && (map?.campaign?.enemySpawns?.length || map?.campaign?.friendlySpawns?.length)){
            try{
              const spE = map.campaign.enemySpawns || [];
              const spF = map.campaign.friendlySpawns || [];
              const _origGet = botManager._getSpawnPosForTeam.bind(botManager);
              botManager._getSpawnPosForTeam = (team)=>{
                if(String(team).toLowerCase() === 'red'){
                  const pick = spE[Math.floor(Math.random()*Math.max(1,spE.length))];
                  if(pick && Array.isArray(pick.pos)){
                    return { x: Number(pick.pos[0])||0, z: Number(pick.pos[2])||0 };
                  }
                }else if(String(team).toLowerCase() === 'blue'){
                  const pick = spF[Math.floor(Math.random()*Math.max(1,spF.length))];
                  if(pick && Array.isArray(pick.pos)){
                    return { x: Number(pick.pos[0])||0, z: Number(pick.pos[2])||0 };
                  }
                }
                return _origGet(team);
              };
            }catch(e){ console.warn('[Campaign] enemy spawns override failed', e); }
          }
          botManager.init?.();
          window.botManager = botManager;
        }catch(e){ console.warn("[Strikegy] BotManager init failed", e); }


        
    // Patch 5A: gather collidables (anything that isn't the player/camera)
    collidableMeshes = [];
    current.scene.traverse((obj)=>{
      if(obj && obj.isMesh){
        // ignore decals/hud helpers
        if(obj.name && (obj.name.startsWith("decal_") || obj.name.startsWith("corpse_"))) return;
        collidableMeshes.push(obj);
      }
    });
    decalManager = new DecalManager(current.scene);
    soundSystem = new SoundSystem();
    window.soundSystem = soundSystem;
    // HF9-B2: high-quality TTS (via proxy endpoint; disabled until configured)
    try{
      window.ttsManager = new TTSManager({ soundSystem });
    }catch(e){ console.warn('[TTS] init failed', e); }
    // WebAudio unlock: browsers block sound until a user gesture
    window.addEventListener('mousedown', ()=> soundSystem?.unlock?.(), { once:true });
    window.addEventListener('touchstart', ()=> soundSystem?.unlock?.(), { once:true, passive:true });
    muzzleFlash = new MuzzleFlash(current.scene, camera);
    // Patch 7-3C: casings/shells (pooled)
    casingSystem = new CasingSystem(current.scene, camera, { maxCount: 80, lifeSeconds: 30 });
    weaponSystem = new WeaponSystem({
      camera: camera,
      scene: current.scene,
      getCollidables: ()=> collidableMeshes,
      getDamageables: ()=> window.damageSystem?.getDamageableMeshes?.() || [],
      onWallHit: (hit)=> decalManager.add(hit),
      // Patch 8-2: hitscan -> damageable entity hit
      onEntityHit: (hit, weapon)=>{
        try{
          const ds = window.damageSystem;
          const ent = ds?.getEntityFromHitObject?.(hit?.object);
          if(!ent || !ent.alive) return;
          const myTeam = window.playerProfile?.team || "blue";
          if(ent.team && ent.team === myTeam) return; // no friendly fire (for now)

          const isHead = ds.isHeadshot(hit, ent);
          const base = Number(weapon?.damage) || 25;
          const mult = isHead ? (Number(weapon?.headshotMult) || 1.5) : 1;
          const diff = window.__difficulty || { playerDamage: 1, enemyDamage: 1 };
          const dmg = Math.round(base * mult * (Number(diff.playerDamage) || 1));

          const res = ds.applyDamage(ent.id, dmg, { weaponId: weapon?.id || null, sourceTeam: myTeam, headshot: isHead });
          // Economy: damage pays per damage; headshot damage pays 2x
          try{ economyManager?.rewardDamage?.(dmg, isHead); }catch{}
          if(res?.killed){
            try{ economyManager?.rewardKill?.(); }catch{}
            try{ modeSystem?.onDeath?.(ent.team); }catch{}
          }
          // Lightweight feedback for debugging
          if(res?.ok){
            window.combatUI?.hitMarker?.({ killed: !!res.killed, headshot: !!res.headshot });
            console.log(`[DMG] hit ${ent.id} ${isHead ? "HEAD" : "BODY"} -${dmg} (hp ${ent.hp}/${ent.maxHp})`);
          }
        }catch(e){ console.warn(e); }
      },
      onSound: (name)=> soundSystem.play(name),
      onEject: (payload)=>{
        // SR ejects on bolt timing; others immediate.
        casingSystem?.spawn?.({ mode: payload?.mode || "", weaponId: payload?.weaponId || "" });
      },
      // Patch 7-2B: muzzle flash + recoil kick
      onShot: (payload)=>{
        muzzleFlash.spawn();
        // Patch 2-FP: viewmodel recoil kick
        try{ viewModelSystem?.onShot?.(payload); }catch(e){}
        if(!cameraController) return;
        const wid = payload?.weaponId || weaponSystem?.currentId;
        const isADSNow = !!(payload?.isADS ?? weaponSystem?.isADS);
        const p = recoilPresetFor(wid);
        // ADS reduces recoil
        const mul = isADSNow ? 0.7 : 1.0;
        // yaw kick randomizes direction
        const yawKick = (Math.random()*2-1) * p.yaw * mul;
        cameraController.addRecoil(p.pitch * mul, yawKick);
      },
    });
    // Patch 6-3: weapon/slot switching manager (guns + grenades + class items + melee)
    weaponSwitchManager = new WeaponSwitchManager({
      profile: window.playerProfile,
      weaponSystem,
      onMelee: ()=>{
        soundSystem?.play?.("swap"); // placeholder SFX
        window.combatUI?.meleeSwing?.();
      },
    });
    weaponSwitchManager.ensureActiveSlot?.();
    // sync to current slot
    weaponSwitchManager.togglePrimarySecondary?.(); // will settle to owned slot

    // Patch 2-FP: create first-person viewmodel (hands + weapon)
    try{
      viewModelSystem = new ViewModelSystem({
        camera,
        weaponSystem,
        getActiveSlot: ()=> (weaponSwitchManager?.meleeActive ? { type:'melee', index:0 } : window.playerProfile?.activeSlot),
        getInventory: ()=> window.playerProfile?.inventory,
      });
      window.viewModelSystem = viewModelSystem;
    }catch(e){ console.warn('[ViewModel] init failed', e); }

	    // Patch 7-2A: smooth ADS FOV (initialize)
	    lastFov = camera.fov;

            // Patch 7-2B / 7-4A: cache overlay elements
            scopeOverlayEl = document.getElementById('scopeOverlay');
            binoOverlayEl = document.getElementById('binoOverlay');
            crosshairEl = document.getElementById('crosshair');
            smokeOverlayEl = document.getElementById('smokeOverlay');
            flashOverlayEl = document.getElementById('flashOverlay');

            // Patch 7-4A: throwables system
            throwablesSystem = new ThrowablesSystem({
              camera,
              scene: current.scene,
              getCollidables: ()=> collidableMeshes,
              getPlayerPosition: ()=> (playerObject?.position ? playerObject.position : null),
              getPlayerTeam: ()=> (window.playerProfile?.team || "blue"),
              onSound: (name)=> soundSystem?.play?.(name),
              onCameraKick: (pitch, yaw)=> cameraController?.addRecoil?.(pitch, yaw),
              onLookLock: (sec)=> inputManager?.setLookLocked?.(sec),
              isMobile: (typeof window!=='undefined' && !!window.__isMobile) ? true : undefined,
              onDamage: (payload)=> applyExplosionDamageToLocal(payload),
              onEffect: (payload)=> { try{ window.botManager?.applyAoEEffect?.(payload); }catch(e){} },
              onOverlay: ({ smoke, flash })=>{
                // Smoke: blur + light desaturation tint
                if(smokeOverlayEl){
                  // Dense smoke: near-opaque inside
                  const o = Math.min(0.985, smoke * 0.985);
                  smokeOverlayEl.style.opacity = String(o);
                  // backdropFilter is expensive on mobile; keep it mild
                  const isM = (typeof window!=='undefined' && !!window.__isMobile);
                  const blur = isM ? (smoke * 8).toFixed(1) : (smoke * 18).toFixed(1);
                  smokeOverlayEl.style.backdropFilter = `blur(${blur}px)`;
                  smokeOverlayEl.style.webkitBackdropFilter = `blur(${blur}px)`;
                }
                // Flash: whiteout overlay
                if(flashOverlayEl){
                  flashOverlayEl.style.opacity = String(Math.min(1, flash));
                }
              }
            });

            // Patch 7-4B: shared ammo refill engine (ammo_pack + shop ammo refills)
            ammoRefillService = new AmmoRefillService({
              profile: window.playerProfile,
              weaponSystem,
              onStatus: (text, blink)=>{
                const elS = document.getElementById('ammoStatus');
                if(!elS) return;
                if(text){ elS.textContent = String(text); }
                else{
                  // don't clear if weapon reload/empty is active; HUD update loop will handle it
                }
                if(blink) elS.classList.add('blink');
              }
            });

            // expose for ShopSystem (ammo refill utilities)
            window.ammoRefillService = ammoRefillService;
            try{ window.playerProfile.ammoRefillService = ammoRefillService; }catch{}

            // Patch 7-4B: class item system (Key6/7 use + binocular zoom)
            // Campaign mode disables classes entirely.
            if(campaignOn || (window.__campaignRules && window.__campaignRules.noClass)){
              classItemSystem = null;
            }else classItemSystem = new ClassItemSystem({
              profile: window.playerProfile,
              camera,
              scene: current.scene,
	              collisionWorld,
              getCollidables: ()=> collidableMeshes,
              getPlayerObject: ()=> playerObject,
              getEntities: ()=> [{ position: playerObject?.position, hp: window.playerHp, maxHp: window.playerMaxHp, team: window.playerProfile?.team || 'blue' }],
              throwablesSystem,
              ammoRefill: ammoRefillService,
              onSound: (name)=> soundSystem?.play?.(name),
              onHUD: (payload)=>{
                // binocular UI is handled below in the HUD update loop
              }
            });

            // Patch 7-4B: binocular +/- buttons (mobile-friendly)
            if(!window.__strikegyBinoBound){
              window.__strikegyBinoBound = true;
              const m = document.getElementById('binoMinus');
              const p = document.getElementById('binoPlus');
              if(m) m.addEventListener('click', (e)=>{ e.preventDefault(); classItemSystem?.adjustBinoZoom?.(-1); });
              if(p) p.addEventListener('click', (e)=>{ e.preventDefault(); classItemSystem?.adjustBinoZoom?.(+1); });
              // prevent click from also firing
              if(m) m.addEventListener('mousedown', (e)=> e.stopPropagation());
              if(p) p.addEventListener('mousedown', (e)=> e.stopPropagation());
              if(m) m.addEventListener('touchstart', (e)=> e.stopPropagation(), { passive:false });
              if(p) p.addEventListener('touchstart', (e)=> e.stopPropagation(), { passive:false });
            }
    // Patch 5A/6: PC bindings
    // (guard to avoid duplicate binds when reloading maps)
    if(!window.__strikegyBoundInputs){
      window.__strikegyBoundInputs = true;

      const isUIBlockedNow = ()=> (window.__strikegyUILock && (window.__strikegyUILock.inventory || window.__strikegyUILock.shop));

      window.addEventListener('contextmenu', (e)=> e.preventDefault());
      window.addEventListener('mousedown', (e)=>{
        if(isUIBlockedNow()) return;
        if(e.button===0) mouseLeftDown = true;
        if(e.button===2) mouseRightDown = true;
      });
      window.addEventListener('mouseup', (e)=>{
        if(isUIBlockedNow()) return;
        if(e.button===0) mouseLeftDown = false;
        if(e.button===2) mouseRightDown = false;
      });

      window.addEventListener('wheel', (e)=>{
        if(isUIBlockedNow()) return;
        // Patch 7-4B: binocular zoom uses wheel while aiming
        if(classItemSystem && classItemSystem.isBinoAiming?.()){
          const used = classItemSystem.onWheel?.(e);
          if(used){ e.preventDefault(); return; }
        }
        weaponSwitchManager?.cycleNext?.();
        e.preventDefault();
      }, { passive:false });

      window.addEventListener('keydown', (e)=>{
        if(isUIBlockedNow()) return;

        // reload (only when holding a gun)
        if(e.code==='KeyR'){
          const a = window.playerProfile?.activeSlot;
          if(a && (a.type==='primary' || a.type==='secondary')){
            weaponSystem?.startReload?.();
          }
          return;
        }

        // switching (Patch 6-3)
        if(e.code==='Digit1'){ weaponSwitchManager?.switchToPrimary?.(); return; }
        if(e.code==='Digit2'){ weaponSwitchManager?.switchToSecondary?.(); return; }
        if(e.code==='Digit3'){ weaponSwitchManager?.switchToGrenade?.(0); return; }
        if(e.code==='Digit4'){ weaponSwitchManager?.switchToGrenade?.(1); return; }
        if(e.code==='Digit5'){ weaponSwitchManager?.switchToGrenade?.(2); return; }
        if(e.code==='Digit6'){ weaponSwitchManager?.switchToClassItem?.(0); return; }
        if(e.code==='Digit7'){ weaponSwitchManager?.switchToClassItem?.(1); return; }
        if(e.code==='KeyF'){ weaponSwitchManager?.triggerMeleeAttack?.(); return; }
      });
    }
document.getElementById("status").textContent =
          "로드 완료. 캔버스를 클릭하면(PC) 포인터락이 걸리고 시점 회전만 활성화됩니다. (Patch 4A)";
      } catch (e){
        console.error(e);
        document.getElementById("status").textContent = "로드 실패";
        showError(path, e);
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      try{ soundSystem?.update?.(dt); }catch(e){}
      try{ rewardFloat?.update?.(dt); }catch(e){}
      // Patch 3-CAMP+: campaign update (cutscenes/dialogue/objectives/checkpoints)
      try{ campaignRuntime?.update?.(dt); }catch(e){}
      // Patch 9-1: Mode rules tick + objective/capture HUD update (throttled)
      try{
        modeSystem?.update?.(dt, {
          playerPos: playerObject?.position || null,
          playerTeam: (window.playerProfile?.team || "blue"),
          playerAlive: !playerDead,
          bots: botManager?.bots || []
        });

        // Patch 9-3C: economy hooks from mode events (capture tick / capture complete)
        try{
          const evs = modeSystem?.consumeEvents?.() || [];
          for(const ev of evs){
            if(!ev) continue;
            if(ev.type === "ZONE_CAPTURING"){
              const ids = Array.isArray(ev.ids) ? ev.ids : [];
              const n = Math.max(1, ids.length || 1);
              for(const id of ids){
                if(id === "player") economyManager?.rewardZoneCapturing?.(ev.dt, n);
                else {
                  const b = botManager?.bots?.find?.(x=>String(x.id)===String(id));
                  b?.economy?.rewardZoneCapturing?.(ev.dt, n);
                }
              }
            }
            if(ev.type === "ZONE_CAPTURE"){
              const ids = Array.isArray(ev.ids) ? ev.ids : [];
              const n = Math.max(1, ids.length || 1);
              for(const id of ids){
                if(id === "player") economyManager?.rewardZoneCapture?.(n);
                else {
                  const b = botManager?.bots?.find?.(x=>String(x.id)===String(id));
                  b?.economy?.rewardZoneCapture?.(n);
                }
              }
            }
          }
        }catch(e){}
        _modeUiAcc += dt;
        if(_modeUiAcc >= 0.08){
          _modeUiAcc = 0;
          window.combatUI?.setModeState?.(modeSystem?.getUIState?.({ playerPos: playerObject?.position || null }));
        }
      }catch(e){}

      try{
      const __campPaused = (document?.body?.dataset?.campCutscene === '1');
      // Patch 8-0PRO: respawn timer tick
      if(!__campPaused && playerDead){
        // Campaign: no auto-respawn (use checkpoint restart)
        if(window.__campaign?.isCampaign?.() && window.campaignRuntime){
          window.combatUI?.setRespawning?.('');
        }else{
          respawnLeft -= dt;
          window.combatUI?.setRespawning?.(Math.max(0, Math.ceil(respawnLeft)));
          if(respawnLeft <= 0) respawnPlayer();
        }
      }
      // Patch 8-2PRO: Bandage healing tick
      if(!__campPaused && !playerDead && bandageHealing){
        const next = playerHP + (bandageHealRate * dt);
        if(next >= playerHPMax){
          setHP(playerHPMax);
          stopBandageHealing();
        }else{
          setHP(next);
        }
      }
      // Campaign: automatic HP regeneration (no bandage)
      const _rules = window.__campaignRules || {};
      if(!__campPaused && !playerDead && _rules.autoRegen && (_rules.noBandage || !bandageHealing)){
        const nowS = (performance.now()||0)/1000;
        if(playerHP < playerHPMax && (nowS - playerLastDamagedAt) >= CAMP_REGEN_DELAY){
          setHP(Math.min(playerHPMax, playerHP + CAMP_REGEN_RATE * dt));
        }
      }
      // Patch 8-1PROA: keep world simulation running even when dead
      // HF9-B2: 컷신 중에는 월드 정지
      if(!__campPaused){
        if(throwablesSystem) throwablesSystem.update(dt);
        if(classItemSystem) classItemSystem.update(dt);
        // Patch 8-3C: bots tick even when player is dead
        try{ botManager?.update?.(dt); }catch{}

        economyManager?.tick?.(dt);
        try{ moneyHUD.textContent = `$${Math.floor(window.playerProfile?.money||0)}`; }catch{}
      }

      // Patch 4: 입력/카메라/플레이어 업데이트
      settingsStore.refresh();
      const controlPreset = settingsStore.controlPreset;
      updateInvBagVisibility();
      const invOpen = inventoryModal.isOpen();
      if(invOpen) mobileHUD.hide(); else if(controlPreset === 'mobile' || controlPreset === 'mobile_kb') mobileHUD.show(); else mobileHUD.hide();
      const st = inputManager.poll(controlPreset);
      if(cameraController && !__campPaused){
        cameraController.applyLookDelta(st.lookDX, st.lookDY, controlPreset !== "pc");
        const dbg = cameraController.getDebug?.();
        if(dbg){
          const yEl = document.getElementById('yawVal');
          const pEl = document.getElementById('pitchVal');
          if(yEl) yEl.textContent = dbg.yawDeg;
          if(pEl) pEl.textContent = dbg.pitchDeg;
        }
      }
      if(playerController && !playerDead && !__campPaused){
        // Patch 7-4I: platform-aware groundY.
        // Our PlayerController uses a simple ground plane (groundY). To let players *stand on top*
        // of inner walls after climbing, we dynamically set groundY to the highest nearby wall top.
        const computePlatformGroundY = (pos, halfH) => {
          try{
            const baseGround = 0;
            const cw = collisionWorld;
            if(!cw || !cw.boxes) return baseGround;
            const r = playerController?.radius ?? 0.38;
            const feetY = pos.y - halfH;
            // allow a forgiving "step" window + hysteresis so standing on ledges isn't jittery
            const prev = (typeof playerController.groundY === 'number') ? playerController.groundY : baseGround;
            const EDGE_PAD = 0.18;

            const overlapXZ = (b, pad=0)=>{
              if(pos.x < b.min.x - r - pad || pos.x > b.max.x + r + pad) return false;
              if(pos.z < b.min.z - r - pad || pos.z > b.max.z + r + pad) return false;
              return true;
            };

            // Hysteresis: if we were already standing on a platform, keep it a bit longer near edges
            // to avoid flicker (0 <-> wallTop) while walking.
            let best = baseGround;
            if(prev > 0){
              for(const b of cw.boxes){
                if(!b || b.type !== 'wall') continue;
                const top = b.max.y;
                if(Math.abs(top - prev) > 0.02) continue;
                if(!overlapXZ(b, EDGE_PAD)) continue;
                if(feetY >= top - 0.55 && feetY <= top + 0.95){
                  best = top;
                  break;
                }
              }
            }

            // Switching window: tight-ish below, generous above.
            // (We only switch *up* when feet are already close to the higher platform.)
            const SNAP_BELOW = 0.25;
            const SNAP_ABOVE = 0.65;

            for(const b of cw.boxes){
              if(!b || b.type !== 'wall') continue; // only walls are intended as climb platforms
              if(!overlapXZ(b, 0)) continue;
              const top = b.max.y;
              // feet close enough to treat as ground
              if(feetY >= top - SNAP_BELOW && feetY <= top + SNAP_ABOVE){
                if(top > best) best = top;
              }
            }
            return best;
          }catch{ return 0; }
        };

        // Patch 7-4B+: Sniper ladder auto-climb assist (does not pause world)
        const climb = classItemSystem?.getClimbAssist?.(st, dt) || null;
        if(climb && climb.active){
          // While climbing: optionally lock horizontal movement, and disable floor clamp so we don't get snapped down.
          if(climb.lockXZ){ st.moveX = 0; st.moveZ = 0; }
          // Top-out (stepping onto a ledge): push slightly towards the wall and snap to the ladder top.
          if(climb.topOut){
            playerController.vy = 0;
            playerController.gravity = 18;
            // When top-out snaps us onto a wall top, immediately adopt that platform as ground.
            // This prevents the XZ resolver from shoving us off due to being "inside" a wall AABB.
            const halfH = playerController.isCrouched ? playerController.halfHeightCrouch : playerController.halfHeightStand;
            // Patch 7-4J: place onto *surface* using capsule half-height so feet end up above the top face.
            if(climb.placeOnSurface && typeof climb.surfaceY === 'number'){
              playerObject.position.y = Math.max(playerObject.position.y, climb.surfaceY + halfH + 0.02);
            }else if(typeof climb.snapY === 'number'){
              playerObject.position.y = Math.max(playerObject.position.y, climb.snapY);
            }
            if(typeof climb.setX === 'number') playerObject.position.x = climb.setX;
            if(typeof climb.setZ === 'number') playerObject.position.z = climb.setZ;
            playerController.groundY = computePlatformGroundY(playerObject.position, halfH);
          }else{
            playerController.gravity = 0;
            playerController.vy = 0;
            playerController.groundY = -9999;
            playerObject.position.y += (climb.deltaY || 0);
          }
        }else{
          playerController.gravity = 18;
          const halfH = playerController.isCrouched ? playerController.halfHeightCrouch : playerController.halfHeightStand;
          playerController.groundY = computePlatformGroundY(playerObject.position, halfH);
        }
        // Campaign cutscene lock: freeze player movement/inputs (camera is driven by script)
        const _campLocked = !!(campaignRuntime?.isPlayerLocked?.());
        if(!_campLocked){
          playerController.update(dt, st, camera, collisionWorld);
        }else{
          st.moveX = 0; st.moveZ = 0;
        }


        // Patch 8-1: minimap tick
        try{
          const dbg = cameraController?.getDebug?.();
          let yawRad = 0;
          // Prefer debug yaw when available
          if (dbg && Number.isFinite(Number(dbg.yawDeg))) {
            yawRad = Number(dbg.yawDeg) * Math.PI / 180;
          } else {
            // Fallback: derive yaw from camera forward direction
            try {
              const dir = new THREE.Vector3();
              camera.getWorldDirection(dir);
              // yaw 0 = facing +Z (adjust if your world uses different forward)
              yawRad = Math.atan2(dir.x, dir.z);
            } catch (e) {
              yawRad = Number(camera?.rotation?.y) || 0;
            }
          }
          // Patch 8-3A: push bot markers into minimap
          window.minimap?.setMarkers?.(botManager?.getMinimapMarkers?.() || []);
          window.minimap?.updatePlayer?.({ x: playerObject.position.x, z: playerObject.position.z, yawRad, team: (playerTeam||'BLUE') });
          window.minimap?.draw?.();
        }catch(e){ /* ignore */ }
      }

      // 아주 미세한 분위기: zone edge만 살짝 펄스 (가독성)
      if(current?.scene){
        // nothing heavy
      }
    // Patch 5B-2: weapons tick (PC + Mobile HUD)
    if(weaponSystem && !playerDead && !__campPaused){
      const preset = settingsStore.controlPreset;
      // Patch 7-3C: casing limit per platform (PC 80 / Mobile 30)
      const casingMax = (preset === 'pc') ? 80 : 30;
      casingSystem?.setLimits?.({ maxCount: casingMax, lifeSeconds: 30 });
      const hudActive = (preset === 'mobile' || preset === 'mobile_kb') && !mobileHUD.el.classList.contains('hidden');
      const hudState = hudActive ? mobileHUD.state : null;
      // Patch 9-4F: bandage button only shows when HP < max
      if(hudActive){
        try{ mobileHUD.setBandageVisible?.(!playerDead && playerHP < playerMaxHP); }catch(e){}
      }

      // Compose triggers: keep PC behavior intact, add mobile held/toggle
      const uiBlocked = (inventoryModal && inventoryModal.isOpen && inventoryModal.isOpen()) || (shopModal && shopModal.isOpen && shopModal.isOpen());
      if(uiBlocked){
        // prevent accidental shots/ADS while interacting with UI
        mouseLeftDown = false;
        mouseRightDown = false;
      }
      const aSlot = window.playerProfile?.activeSlot;
      const holdingGun = !!aSlot && (aSlot.type === 'primary' || aSlot.type === 'secondary');
      const invNow = window.playerProfile?.inventory || null;
      const grenadeActive = !!aSlot && (aSlot.type === 'grenade');
      const grenadeId = grenadeActive ? (invNow?.grenades?.[aSlot.index] || null) : null;
      const classActive = !!aSlot && (aSlot.type === 'classItem');
      const classId = classActive ? (invNow?.classItems?.[aSlot.index] || null) : null;
      const meleeActive = !!weaponSwitchManager?.meleeActive;
      const fireHeld = !uiBlocked && holdingGun && !meleeActive && (!!mouseLeftDown || !!(hudState && hudState.fireHeld));
      const adsOn = !uiBlocked && holdingGun && !meleeActive && (!!mouseRightDown || !!(hudState && hudState.adsOn));

      // Patch 7-4A: grenade hold/release throw (PC + Mobile)
      const grenadeHold = !uiBlocked && grenadeActive && !meleeActive && !!grenadeId && (!!mouseLeftDown || !!(hudState && hudState.fireHeld));
      if(throwablesSystem){
        // If UI opened mid-hold, cancel.
        if(uiBlocked && (prevGrenadeHold || throwablesSystem.holding)){
          throwablesSystem.cancelHold?.();
          prevGrenadeHold = false;
        }else{
          if(grenadeHold && !prevGrenadeHold){
            throwablesSystem.beginHold?.(grenadeId, aSlot.index);
          }
          if(!grenadeHold && prevGrenadeHold){
            const spawned = throwablesSystem.releaseThrow?.(grenadeId, aSlot.index);
            if(spawned && invNow && Array.isArray(invNow.grenades)){
              invNow.grenades[aSlot.index] = null; // consume
              weaponSwitchManager?.cycleNext?.();  // auto leave empty grenade slot
            }
          }
          if(!grenadeActive && (prevGrenadeHold || throwablesSystem.holding)){
            throwablesSystem.cancelHold?.();
          }
          prevGrenadeHold = grenadeHold;
        }
      }

      // Patch 7-4B: class item use (press-to-use, no world pause)
      const classPress = !uiBlocked && classActive && !meleeActive && !!classId && (!!mouseLeftDown || !!(hudState && hudState.fireHeld));
      if(classItemSystem){
        if(classPress && !prevClassUse){
          classItemSystem.use?.(aSlot.index|0);
          // consume the click edge so it doesn't accidentally shoot next frame
          mouseLeftDown = false;
        }
        prevClassUse = !!classPress;
      }

      // Binocular aiming piggybacks on ADS input when classItem=binocular
      if(classItemSystem){
        const binoShouldAim = (!uiBlocked && classActive && (classId === 'binocular') && (!!mouseRightDown || !!(hudState && hudState.adsOn)));
        classItemSystem.setBinocularAiming?.(binoShouldAim);
      }

      weaponSystem.setTriggerHeld(fireHeld);
      weaponSystem.setADS(adsOn);

      // Patch 7-2A: weapon hold/ADS movement multipliers (applied in PlayerController)
      // - Holding gun: 0.95
      // - ADS: 0.85 (default) / 0.75 (LMG)
      let weaponSpeedMul = 1.0;
      if(!uiBlocked && holdingGun && !meleeActive){
        weaponSpeedMul *= 0.95;
        if(adsOn){
          const wid = (weaponSystem?.currentId || weaponSystem?.current?.id || "");
          const isLMG = (typeof wid === 'string' && wid.startsWith('lmg')) || (weaponSystem?.current?.name || '').startsWith('LMG');
          weaponSpeedMul *= isLMG ? 0.75 : 0.85;
        }
      }
      if(playerController) playerController.weaponSpeedMul = weaponSpeedMul;

      // One-shot actions (consume pulses in HUD after handling)
      if(!uiBlocked && holdingGun && hudState && hudState.reloadPressed){
        weaponSystem.startReload?.();
      }
      if(!uiBlocked && hudState && hudState.nextWeaponPressed){
        // Patch 7-3B: mobile next weapon = full cycle (includes grenades, excludes melee)
        weaponSwitchManager?.cycleNext?.();
      }
      if(!uiBlocked && hudState && hudState.meleePressed){
        weaponSwitchManager?.triggerMeleeAttack?.();
      }
      // Patch 9-4F: mobile bandage button
      if(!uiBlocked && hudState && hudState.bandagePressed){
        if(!playerDead && playerHP < playerMaxHP){
          startBandageHealing();
        }
      }
      if(!uiBlocked && hudState && (hudState.reloadPressed || hudState.nextWeaponPressed || hudState.meleePressed || hudState.bandagePressed)){
        mobileHUD.consumePulses?.();
      }
weaponSwitchManager?.update?.(dt);
// Campaign cutscene lock: block firing/reload/weapon logic
if(!(campaignRuntime?.isPlayerLocked?.())){
  weaponSystem.update(dt);
}
      // (moved) throwablesSystem update handled earlier
if(decalManager) decalManager.update(dt);
      if(muzzleFlash) muzzleFlash.update(dt);
      if(casingSystem) casingSystem.update(dt);
      if(casingSystem) casingSystem.update(dt);

      // Patch 7-2B: recoil recovery (frame independent)
      // Campaign cutscenes drive the camera via keyframes, so recoil must not overwrite view.
      if(cameraController && !(campaignRuntime?.isPlayerLocked?.())){
        const wid = (weaponSystem?.currentId || weaponSystem?.current?.id || "");
        const p = recoilPresetFor(wid);
        const rs = weaponSystem.isADS ? p.retAds : p.retHip;
        cameraController.updateRecoil(dt, rs);
      }

      // Patch 7-2A + 7-4B: smooth ADS FOV (frame-rate independent) + binocular zoom
      const binoActive = !!(classItemSystem && classItemSystem.isBinoAiming?.());
      const baseFov = (classItemSystem?.bino?.baseFov ?? camera?.fov ?? 75);
      const binoFov = baseFov / (classItemSystem?.bino?.zoom ?? 8);
      const targetFov = binoActive
        ? binoFov
        : (weaponSystem.isADS ? weaponSystem.current.adsFov : weaponSystem.current.hipFov);
      if(camera){
        if(lastFov == null) lastFov = camera.fov;
        const speed = (binoActive || weaponSystem.isADS) ? 18 : 14;
        const t = 1 - Math.exp(-speed * dt);
        lastFov = lastFov + (targetFov - lastFov) * t;
        if(Math.abs(camera.fov - lastFov) > 1e-3){
          camera.fov = lastFov;
          camera.updateProjectionMatrix();
        }
      }

      // Patch 7-2B + 7-4B: scope overlay + binocular overlay + crosshair hide
      const scope = (!binoActive && weaponSystem.isADS) ? (weaponSystem.current.scope || '') : '';
      const scopeActive = !!scope;
      if(scopeOverlayEl){
        scopeOverlayEl.style.display = scopeActive ? 'block' : 'none';
        if(scopeActive) scopeOverlayEl.setAttribute('data-scope', scope);
      }
      if(binoOverlayEl){
        binoOverlayEl.style.display = binoActive ? 'block' : 'none';
      }
      if(crosshairEl){
        crosshairEl.style.display = (scopeActive || binoActive) ? 'none' : 'block';
      }

      // HUD
      const elMag = document.getElementById('ammoMag');
      const elRes = document.getElementById('ammoRes');
      const elW = document.getElementById('ammoWeapon');
      const elS = document.getElementById('ammoStatus');
      const aSlotHud = window.playerProfile?.activeSlot;
      const invHud = window.playerProfile?.inventory || null;
      const grenadeActiveHud = !!aSlotHud && aSlotHud.type === 'grenade';
      const classInfo = classItemSystem?.getHUDInfo?.();
      if(classInfo){
        if(elW) elW.textContent = classInfo.weapon || '';
        if(elMag) elMag.textContent = classInfo.magText ?? '';
        if(elRes) elRes.textContent = classInfo.resText ?? '';
      }else if(grenadeActiveHud){
        const gid = invHud?.grenades?.[aSlotHud.index] || null;
        if(elW) elW.textContent = grenadeHudName(gid);
        if(elMag) elMag.textContent = gid ? '1' : '0';
        if(elRes) elRes.textContent = '';
      }else{
        if(elMag) elMag.textContent = weaponSystem.mag;
        if(elRes) elRes.textContent = weaponSystem.reserve;
        if(elW) elW.textContent = weaponSystem.current.name;
      }
      const elSlot = document.getElementById('ammoSlot');
      if(elSlot) elSlot.textContent = weaponSwitchManager?.getActiveLabel?.() || '';

      if(elS){
        if(classInfo){
          elS.textContent = classInfo.status || '';
          if(classInfo.blink) elS.classList.add('blink'); else elS.classList.remove('blink');
        }else if(grenadeActiveHud){
          const gid = invHud?.grenades?.[aSlotHud.index] || null;
          if(!gid){ elS.textContent = 'EMPTY'; elS.classList.add('blink'); }
          else { elS.textContent = ''; elS.classList.remove('blink'); }
        }else{
          if(weaponSystem.isReloading){ elS.textContent = 'RELOADING'; elS.classList.add('blink'); }
          else if(weaponSystem.mag===0 && weaponSystem.reserve===0){ elS.textContent = 'EMPTY'; elS.classList.add('blink'); }
          else { elS.textContent = ''; elS.classList.remove('blink'); }
        }
      }

      // Patch 7-4B: binocular HUD
      const binoHUD = document.getElementById('binoHUD');
      if(binoHUD){
        const show = !!(classItemSystem && classItemSystem.isBinoAiming?.());
        binoHUD.style.display = show ? 'flex' : 'none';
        if(show){
          const t = document.getElementById('binoText');
          const z = classItemSystem?.bino?.zoom;
          if(t && z) t.textContent = `${z}x`;
        }
      }
    }

      // Patch 2-FP: viewmodel tick (항상 업데이트 / 죽으면 숨김)
      try{
        if(viewModelSystem){
          const _cine = (document?.body?.dataset?.campCutscene === '1');
          viewModelSystem.setVisible?.(!playerDead && !_cine);
          if(!_cine) viewModelSystem.update?.(dt, st, { playerDead });
        }
      }catch(e){}

            }catch(e){
        console.error("animate error", e);
      }


      // Patch 8-1: minimap tick
      try{
        const mm = window.minimap;
        if(mm){
          const po = (typeof playerObject !== "undefined" && playerObject) ? playerObject : null;
          const px = po ? po.position.x : (playerController?.playerObject?.position?.x ?? 0);
          const pz = po ? po.position.z : (playerController?.playerObject?.position?.z ?? 0);
          const yaw = (camera?.rotation?.y ?? 0);
          const team = String(window.playerProfile?.team || "blue").toUpperCase();
          // Patch 8-3A: bot markers
          mm.setMarkers?.(botManager?.getMinimapMarkers?.() || []);
          mm.updatePlayer?.({ x: px, z: pz, yawRad: yaw, team });
          if(Array.isArray(current?.zones) && current.zones.length){
            mm.updateZoneStates?.(current.zones);
          }
          mm.draw?.();
        }
      }catch(e){ /* ignore minimap */ }

if(current?.scene){
        if(postFX){
          postFX.setScene(current.scene);
          postFX.render();
        }else{
          renderer.render(current.scene, camera);
        }
      }
    }

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      try{ postFX?.resize?.(); }catch(e){}
    });

    // Patch 10: in-game menu
    const gameMenuBtn = document.getElementById('gameMenuBtn');
    const gameMenuOverlay = document.getElementById('gameMenuOverlay');
    const gmResume = document.getElementById('gmResume');
    const gmReload = document.getElementById('gmReload');
    const gmLobby = document.getElementById('gmLobby');

    function openGameMenu(){
      try{ document.exitPointerLock?.(); }catch(e){}
      gameMenuOverlay?.classList.add('open');
      gameMenuOverlay?.setAttribute('aria-hidden','false');
    }
    function closeGameMenu(){
      gameMenuOverlay?.classList.remove('open');
      gameMenuOverlay?.setAttribute('aria-hidden','true');
    }
    gameMenuBtn?.addEventListener('click', openGameMenu);
    gmResume?.addEventListener('click', closeGameMenu);
    gmReload?.addEventListener('click', () => { closeGameMenu(); boot(); });
    gmLobby?.addEventListener('click', () => { window.location.href = 'index.html'; });
    gameMenuOverlay?.addEventListener('click', (e) => {
      if(e.target === gameMenuOverlay) closeGameMenu();
    });
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape'){
        if(gameMenuOverlay?.classList.contains('open')) closeGameMenu();
        else openGameMenu();
      }
    });

    // UI hooks
    document.getElementById("backBtn").addEventListener("click", () => {
      window.location.href = "index.html";
    });
    document.getElementById("reloadBtn").addEventListener("click", () => boot());
    document.getElementById("retryBtn").addEventListener("click", () => boot());
    document.getElementById("toLobbyBtn").addEventListener("click", () => {
      window.location.href = "index.html";
    });

    // Start
    await boot();
    animate();
  

  // Patch 11-A: multiplayer bootstrap banner (no sync yet)
  // Patch 0-F: 멀티플레이 부트스트랩 제거
  </script>
  <!-- Patch 7-2B: scope overlay (shown only when ADS + weapon has scope) -->
  <div id="scopeOverlay" data-scope="3x">
    <div class="mask"></div>
    <div class="reticle"></div>
  </div>
  <div id="binoOverlay">
    <div class="mask"></div>
    <div class="reticle"></div>
  </div>
  <div id="smokeOverlay"></div>
  <div id="flashOverlay"></div>
<div id="crosshair" style="position:fixed;left:50%;top:50%;width:16px;height:16px;transform:translate(-50%,-50%);pointer-events:none">
<div style="position:absolute;left:7px;top:0;width:2px;height:16px;background:#fff"></div>
<div style="position:absolute;left:0;top:7px;width:16px;height:2px;background:#fff"></div></div>

  <!-- Patch 9-4D: floating reward texts (BF-style) -->
  <div id="rewardFloat" class="rewardFloat"></div>
<div id="ammoHUD" class="ammoHUD">
    <div class="ammoWeapon" id="ammoWeapon">AR-1</div>
    <div class="ammoSlot" id="ammoSlot"></div>
    <div class="ammoNums"><span id="ammoMag">30</span><span class="ammoSep">—</span><span id="ammoRes">90</span></div>
    <div class="ammoStatus" id="ammoStatus"></div>
  </div>

  <!-- Patch 7-4B: binocular zoom HUD (only visible while aiming with binocular) -->
  <div id="binoHUD" class="binoHUD" style="display:none">
    <button id="binoMinus" class="binoBtn" tabindex="-1">-</button>
    <div id="binoText" class="binoText">8x</div>
    <button id="binoPlus" class="binoBtn" tabindex="-1">+</button>
  </div>

  </body>
</html>